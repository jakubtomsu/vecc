#ifndef VECC_DEFINED
#define VECC_DEFINED 1

// WARNING: this file was generated by the VecC compiler.

#include <stdint.h>
#include <stdio.h>
#include <vecc_builtin.h>

typedef struct { F32 data[9]; } Aos9F32;
typedef struct { U8 data[16]; } Aos16U8;
typedef struct { F32 data[2]; } Aos2F32;
typedef struct { U8 data[4]; } Aos4U8;
typedef struct Effect {
	Aos2F32 pos;
	F32 rad;
	F32 timer;
	F32 dur;
	Aos4U8 color;
} Effect;
typedef struct Hit {
	F32 tmin;
	F32 tmax;
	B8 hit;
} Hit;
typedef struct { I32 data[8]; } Aos8I32;
typedef struct Bullet {
	B8 used;
	Aos2F32 pos;
	Aos2F32 vel;
	F32 timer;
	U8 level;
	B8 explode;
} Bullet;
typedef struct Item {
	Aos2F32 pos;
	I32 powerup;
	F32 timer;
} Item;
typedef struct { Item data[32]; } Aos32Item;
typedef struct { F32 data[8]; } Aos8F32;
typedef struct { U32 data[95]; } Aos95U32;
typedef struct { F32 data[64]; } Aos64F32;
typedef struct { Bullet data[128]; } Aos128Bullet;
typedef struct { F32 data[3]; } Aos3F32;
typedef struct Player {
	Aos2F32 pos;
	Aos2F32 vel;
	Aos2F32 dir;
	F32 gun_timer;
	Aos3F32 powerup_timer;
	F32 particle_timer;
} Player;
typedef struct { Aos3F32 data[4]; } Aos4Aos3F32;
typedef struct Enemy {
	Aos2F32 pos;
	Aos2F32 vel;
	F32 speed;
	F32 health;
	F32 damage_timer;
	U8 size;
	U8 state;
	U8 kind;
} Enemy;
typedef struct { I32 data[2]; } Aos2I32;
typedef struct { Enemy data[256]; } Aos256Enemy;
typedef struct { F32 data[16]; } Aos16F32;
typedef struct { Effect data[8]; } Aos8Effect;
typedef struct { V8F32 data[2]; } Aos2V8F32;
typedef struct { V8U8 data[4]; } Aos4V8U8;
typedef struct V8Effect {
	Aos2V8F32 pos;
	V8F32 rad;
	V8F32 timer;
	V8F32 dur;
	Aos4V8U8 color;
} V8Effect;
typedef struct { V8Effect data[8]; } Aos8V8Effect;
typedef struct { B8 data[3]; } Aos3B8;
typedef struct { V8I32 data[2]; } Aos2V8I32;
static Aos2F32 aos2f32_set(F32 v0, F32 v1) { return {{v0, v1}}; }
static Aos2F32 aos2f32_set1(F32 a) { return {{a, a}}; }
static Aos2I32 aos2f32_to_aos2i32(Aos2F32 a) { return {{(I32)a.data[0], (I32)a.data[1]}}; }
static Aos2F32 aos2f32_add(Aos2F32 a, Aos2F32 b) { return {{a.data[0] + b.data[0], a.data[1] + b.data[1]}}; }
static Aos2F32 aos2f32_sub(Aos2F32 a, Aos2F32 b) { return {{a.data[0] - b.data[0], a.data[1] - b.data[1]}}; }
static Aos2F32 aos2f32_mul(Aos2F32 a, Aos2F32 b) { return {{a.data[0] * b.data[0], a.data[1] * b.data[1]}}; }
static Aos2F32 aos2f32_div(Aos2F32 a, Aos2F32 b) { return {{a.data[0] / b.data[0], a.data[1] / b.data[1]}}; }
static Aos2F32 aos2f32_neg(Aos2F32 a) { return {{-a.data[0], -a.data[1]}}; }
static Aos4U8 aos4u8_set(U8 v0, U8 v1, U8 v2, U8 v3) { return {{v0, v1, v2, v3}}; }
static Aos4U8 aos4u8_set1(U8 a) { return {{a, a, a, a}}; }
static Aos3F32 aos3f32_set(F32 v0, F32 v1, F32 v2) { return {{v0, v1, v2}}; }
static Aos3F32 aos3f32_set1(F32 a) { return {{a, a, a}}; }
static Aos3F32 aos3f32_add(Aos3F32 a, Aos3F32 b) { return {{a.data[0] + b.data[0], a.data[1] + b.data[1], a.data[2] + b.data[2]}}; }
static Aos3F32 aos3f32_sub(Aos3F32 a, Aos3F32 b) { return {{a.data[0] - b.data[0], a.data[1] - b.data[1], a.data[2] - b.data[2]}}; }
static Aos3F32 aos3f32_mul(Aos3F32 a, Aos3F32 b) { return {{a.data[0] * b.data[0], a.data[1] * b.data[1], a.data[2] * b.data[2]}}; }
static Aos3F32 aos3f32_div(Aos3F32 a, Aos3F32 b) { return {{a.data[0] / b.data[0], a.data[1] / b.data[1], a.data[2] / b.data[2]}}; }
static Aos3F32 aos3f32_neg(Aos3F32 a) { return {{-a.data[0], -a.data[1], -a.data[2]}}; }
static Aos4Aos3F32 aos4aos3f32_set(Aos3F32 v0, Aos3F32 v1, Aos3F32 v2, Aos3F32 v3) { return {{v0, v1, v2, v3}}; }
static Aos2I32 aos2i32_set(I32 v0, I32 v1) { return {{v0, v1}}; }
static Aos2I32 aos2i32_set1(I32 a) { return {{a, a}}; }
static Aos2F32 aos2i32_to_aos2f32(Aos2I32 a) { return {{(F32)a.data[0], (F32)a.data[1]}}; }
static Aos2I32 aos2i32_add(Aos2I32 a, Aos2I32 b) { return {{a.data[0] + b.data[0], a.data[1] + b.data[1]}}; }
static Aos2I32 aos2i32_sub(Aos2I32 a, Aos2I32 b) { return {{a.data[0] - b.data[0], a.data[1] - b.data[1]}}; }
static Aos2I32 aos2i32_mul(Aos2I32 a, Aos2I32 b) { return {{a.data[0] * b.data[0], a.data[1] * b.data[1]}}; }
static Aos2I32 aos2i32_div(Aos2I32 a, Aos2I32 b) { return {{a.data[0] / b.data[0], a.data[1] / b.data[1]}}; }
static Aos2I32 aos2i32_and(Aos2I32 a, Aos2I32 b) { return {{a.data[0] & b.data[0], a.data[1] & b.data[1]}}; }
static Aos2I32 aos2i32_or(Aos2I32 a, Aos2I32 b) { return {{a.data[0] | b.data[0], a.data[1] | b.data[1]}}; }
static Aos2I32 aos2i32_xor(Aos2I32 a, Aos2I32 b) { return {{a.data[0] ^ b.data[0], a.data[1] ^ b.data[1]}}; }
static Aos2I32 aos2i32_neg(Aos2I32 a) { return {{-a.data[0], -a.data[1]}}; }
static Aos2V8F32 aos2v8f32_set(V8F32 v0, V8F32 v1) { return {{v0, v1}}; }
static Aos2V8F32 aos2v8f32_set_scalar(Aos2F32 a) { return {{v8f32_set1(a.data[0]), v8f32_set1(a.data[1])}}; }
static Aos2V8F32 aos2v8f32_set1(V8F32 a) { return {{a, a}}; }
static Aos2F32 aos2v8f32_extract(Aos2V8F32 a, I32 index) { return {v8f32_extract(a.data[0], index), v8f32_extract(a.data[1], index)}; }
static Aos2V8F32 aos2v8f32_add(Aos2V8F32 a, Aos2V8F32 b) { return {{v8f32_add(a.data[0], b.data[0]), v8f32_add(a.data[1], b.data[1])}}; }
static Aos2V8F32 aos2v8f32_sub(Aos2V8F32 a, Aos2V8F32 b) { return {{v8f32_sub(a.data[0], b.data[0]), v8f32_sub(a.data[1], b.data[1])}}; }
static Aos2V8F32 aos2v8f32_mul(Aos2V8F32 a, Aos2V8F32 b) { return {{v8f32_mul(a.data[0], b.data[0]), v8f32_mul(a.data[1], b.data[1])}}; }
static Aos4V8U8 aos4v8u8_set(V8U8 v0, V8U8 v1, V8U8 v2, V8U8 v3) { return {{v0, v1, v2, v3}}; }
static Aos4V8U8 aos4v8u8_set_scalar(Aos4U8 a) { return {{v8u8_set1(a.data[0]), v8u8_set1(a.data[1]), v8u8_set1(a.data[2]), v8u8_set1(a.data[3])}}; }
static Aos4V8U8 aos4v8u8_set1(V8U8 a) { return {{a, a, a, a}}; }
static Aos4U8 aos4v8u8_extract(Aos4V8U8 a, I32 index) { return {v8u8_extract(a.data[0], index), v8u8_extract(a.data[1], index), v8u8_extract(a.data[2], index), v8u8_extract(a.data[3], index)}; }
static Aos4V8U8 aos4v8u8_add(Aos4V8U8 a, Aos4V8U8 b) { return {{v8u8_add(a.data[0], b.data[0]), v8u8_add(a.data[1], b.data[1]), v8u8_add(a.data[2], b.data[2]), v8u8_add(a.data[3], b.data[3])}}; }
static Aos4V8U8 aos4v8u8_mul(Aos4V8U8 a, Aos4V8U8 b) { return {{v8u8_mul(a.data[0], b.data[0]), v8u8_mul(a.data[1], b.data[1]), v8u8_mul(a.data[2], b.data[2]), v8u8_mul(a.data[3], b.data[3])}}; }
static Aos4V8U8 aos4v8u8_and(Aos4V8U8 a, Aos4V8U8 b) { return {{v8u8_and(a.data[0], b.data[0]), v8u8_and(a.data[1], b.data[1]), v8u8_and(a.data[2], b.data[2]), v8u8_and(a.data[3], b.data[3])}}; }
static Aos4V8U8 aos4v8u8_or(Aos4V8U8 a, Aos4V8U8 b) { return {{v8u8_or(a.data[0], b.data[0]), v8u8_or(a.data[1], b.data[1]), v8u8_or(a.data[2], b.data[2]), v8u8_or(a.data[3], b.data[3])}}; }
static Aos4V8U8 aos4v8u8_xor(Aos4V8U8 a, Aos4V8U8 b) { return {{v8u8_xor(a.data[0], b.data[0]), v8u8_xor(a.data[1], b.data[1]), v8u8_xor(a.data[2], b.data[2]), v8u8_xor(a.data[3], b.data[3])}}; }
static Effect v8effect_extract(V8Effect a, I32 index) { return {aos2v8f32_extract(a.pos, index), v8f32_extract(a.rad, index), v8f32_extract(a.timer, index), v8f32_extract(a.dur, index), aos4v8u8_extract(a.color, index)}; }
static Aos3B8 aos3b8_set(B8 v0, B8 v1, B8 v2) { return {{v0, v1, v2}}; }
static Aos3B8 aos3b8_set1(B8 a) { return {{a, a, a}}; }
static Aos3B8 aos3b8_not(Aos3B8 a) { return {{!a.data[0], !a.data[1], !a.data[2]}}; }
static Aos2V8I32 aos2v8i32_set(V8I32 v0, V8I32 v1) { return {{v0, v1}}; }
static Aos2V8I32 aos2v8i32_set_scalar(Aos2I32 a) { return {{v8i32_set1(a.data[0]), v8i32_set1(a.data[1])}}; }
static Aos2V8I32 aos2v8i32_set1(V8I32 a) { return {{a, a}}; }
static Aos2I32 aos2v8i32_extract(Aos2V8I32 a, I32 index) { return {v8i32_extract(a.data[0], index), v8i32_extract(a.data[1], index)}; }
static Aos2V8I32 aos2v8i32_add(Aos2V8I32 a, Aos2V8I32 b) { return {{v8i32_add(a.data[0], b.data[0]), v8i32_add(a.data[1], b.data[1])}}; }
static Aos2V8I32 aos2v8i32_sub(Aos2V8I32 a, Aos2V8I32 b) { return {{v8i32_sub(a.data[0], b.data[0]), v8i32_sub(a.data[1], b.data[1])}}; }
static Aos2V8I32 aos2v8i32_mul(Aos2V8I32 a, Aos2V8I32 b) { return {{v8i32_mul(a.data[0], b.data[0]), v8i32_mul(a.data[1], b.data[1])}}; }
static Aos2V8I32 aos2v8i32_and(Aos2V8I32 a, Aos2V8I32 b) { return {{v8i32_and(a.data[0], b.data[0]), v8i32_and(a.data[1], b.data[1])}}; }
static Aos2V8I32 aos2v8i32_or(Aos2V8I32 a, Aos2V8I32 b) { return {{v8i32_or(a.data[0], b.data[0]), v8i32_or(a.data[1], b.data[1])}}; }
static Aos2V8I32 aos2v8i32_xor(Aos2V8I32 a, Aos2V8I32 b) { return {{v8i32_xor(a.data[0], b.data[0]), v8i32_xor(a.data[1], b.data[1])}}; }

// VECC exported constants

const String SAMPLE_NAME = {"120+", 4};
const I32 RESOLUTION_X = 8 * 30;
const I32 RESOLUTION_Y = 8 * 30;
const I32 RESOLUTION_SCALE = 4;
const U32 KEY_LEFT_BIT = 1 << 0;
const U32 KEY_RIGHT_BIT = 1 << 1;
const U32 KEY_UP_BIT = 1 << 2;
const U32 KEY_DOWN_BIT = 1 << 3;
const U32 KEY_Z_BIT = 1 << 4;
const U32 KEY_X_BIT = 1 << 5;

// VECC exported function declarations
void compute_frame(V8U32* framebuffer, Aos2I32 resolution, F32 time, F32 delta, I32 frame, U32 keys, F32* audio_buffer, I32 audio_samples);
#endif // VECC_DEFINED


#ifdef VECC_IMPL

// VECC private function declarations

static void spawn_item(Aos2F32 pos, I32 powerup);
static void spawn_effect(Aos2F32 pos, F32 rad, F32 dur, Aos4U8 color);
static void reset_game();
static void draw_rect(V8U32* framebuffer, Aos2I32 resolution, Aos2I32 pos, Aos2I32 size, Aos4U8 color);
static void draw_octagon(V8U32* framebuffer, Aos2I32 resolution, Aos2I32 pos, I32 size, I32 rad, Aos4U8 color);
static Hit intersect_ray_aabb(Aos2F32 pos, Aos2F32 dir, Aos2F32 box_min, Aos2F32 box_max);
static F32 wave_sin(F32 t);
static F32 wave_square(F32 t);
static F32 wave_saw(F32 t);
static F32 wave_triangle(F32 t);
static F32 wave_noise(F32 t);
static F32 sample_t(I32 index);
static void play_sound(I32 sound);
static void draw_text(V8U32* framebuffer, Aos2I32 resolution, String text, Aos2I32 pos, U32 color);
static void draw_glyph(V8U32* framebuffer, Aos2I32 resolution, U32 glyph, Aos2I32 pos, U32 color);
static U32 rand_u32();
static F32 rand_f32();
static U32 hash_u32(U32 x);
static U32 color_to_u32(Aos4U8 col);
static Aos2F32 normalize(Aos2F32 x);
static F32 length2(Aos2F32 x);
static F32 length(Aos2F32 x);
static F32 dot(Aos2F32 a, Aos2F32 b);

// VECC global variable declarations

const F32 PI = 3.1415927f;
const I32 AUDIO_SAMPLE_RATE = 44100;
const F32 GAME_MAX_TIME = 120.0f;
F32 g_enemy_spawn_timer = 5.0f;
F32 g_game_timer = 0.0f;
U32 g_seed = 1;
Aos2I32 g_camera = {0};
F32 g_shake = 0.0f;
F32 g_hit_pause = 0.0f;
const I32 PLAYER_POWERUP_FAST_FIRE = 0;
const I32 PLAYER_POWERUP_SHOTGUN = 1;
const I32 PLAYER_POWERUP_EXPLOSIVE = 2;
const I32 POWERUP_NUM = 3;
const Aos4U8 POWERUP_FAST_FIRE_COLOR = {{0, 255, 0, 0}};
const Aos4U8 POWERUP_SHOTGUN_COLOR = {{255, 255, 0, 0}};
const Aos4U8 POWERUP_EXPLOSIVE_COLOR = {{0, 255, 255, 0}};
Player player = {0};
Aos32Item g_items = {0};
Aos128Bullet g_bullets = {0};
Aos8V8Effect g_effects = {0};
const U8 ENEMY_STATE_DEAD = 0;
const U8 ENEMY_STATE_ALIVE = 1;
const Aos4U8 ENEMY_COLOR_NORMAL = {{255, 50, 200, 0}};
const Aos4U8 ENEMY_COLOR_FAST = {{200, 0, 255, 0}};
const Aos4U8 ENEMY_COLOR_BIG = {{255, 10, 100, 0}};
Aos256Enemy g_enemies = {0};
const I32 SOUND_BEGIN = 0;
const I32 SOUND_WALK = 1;
const I32 SOUND_HIT = 2;
const I32 SOUND_SHOOT = 3;
const I32 SOUND_EXPLOSION = 4;
const I32 SOUND_KILL = 5;
const I32 SOUND_PICKUP = 6;
const I32 SOUND_SPAWN = 7;
const I32 SOUND_NUM = 8;
Aos8I32 g_sound_sample = {0};
Aos8F32 g_sound_rand = {0};
I32 g_audio_sample = 0;
const Aos9F32 NOTE_C = {{16.35f, 32.7f, 65.41f, 130.81f, 261.63f, 523.25f, 1046.5f, 2093.0f, 4186.0f}};
const Aos9F32 NOTE_CS = {{17.32f, 34.65f, 69.3f, 138.59f, 277.17999f, 554.37f, 1108.72998f, 2217.46f, 4434.9199f}};
const Aos9F32 NOTE_D = {{18.35f, 36.709999f, 73.419998f, 146.83f, 293.66f, 587.33f, 1174.66f, 2349.32f, 4698.6299f}};
const Aos9F32 NOTE_DS = {{19.45f, 38.889999f, 77.779999f, 155.56f, 311.13f, 622.25f, 1244.51f, 2489.0f, 4978.0f}};
const Aos9F32 NOTE_E = {{20.6f, 41.2f, 82.41f, 164.81f, 329.63f, 659.25f, 1318.51f, 2637.0f, 5274.0f}};
const Aos9F32 NOTE_F = {{21.83f, 43.65f, 87.309998f, 174.61f, 349.23f, 698.46f, 1396.91f, 2793.83f, 5587.6499f}};
const Aos9F32 NOTE_FS = {{23.12f, 46.25f, 92.5f, 185.0f, 369.98999f, 739.98999f, 1479.97998f, 2959.96f, 5919.91f}};
const Aos9F32 NOTE_G = {{24.5f, 49.0f, 98.0f, 196.0f, 392.0f, 783.98999f, 1567.97998f, 3135.96f, 6271.93f}};
const Aos9F32 NOTE_GS = {{25.959999f, 51.91f, 103.83f, 207.64999f, 415.29999f, 830.60999f, 1661.21997f, 3322.4399f, 6644.8799f}};
const Aos9F32 NOTE_A = {{27.5f, 55.0f, 110.0f, 220.0f, 440.0f, 880.0f, 1760.0f, 3520.0f, 7040.0f}};
const Aos9F32 NOTE_AS = {{29.139999f, 58.27f, 116.54f, 233.08f, 466.16f, 932.33f, 1864.66f, 3729.31f, 7458.62f}};
const Aos9F32 NOTE_B = {{30.87f, 61.74f, 123.47f, 246.94f, 493.88f, 987.77f, 1975.53f, 3951.0f, 7902.1299f}};
const U8 MUSIC_BEAT_KICK = 1 << 0;
const U8 MUSIC_BEAT_SNARE = 1 << 1;
const U8 MUSIC_BEAT_HIHAT = 1 << 2;
I32 g_music_beat_index = 0;
I32 g_music_beat_sample = 0;
I32 g_music_melody_index = 0;
I32 g_music_melody_sample = 0;
I32 g_music_bass_index = 0;
I32 g_music_bass_sample = 0;
I32 g_music_synth_index = 0;
I32 g_music_synth_sample = 0;
const Aos16U8 g_music_beat = {{MUSIC_BEAT_KICK | MUSIC_BEAT_SNARE, 0, MUSIC_BEAT_HIHAT, 0, MUSIC_BEAT_KICK, 0, MUSIC_BEAT_HIHAT, 0, MUSIC_BEAT_KICK | MUSIC_BEAT_HIHAT, 0, 0, MUSIC_BEAT_HIHAT, MUSIC_BEAT_KICK, 0, MUSIC_BEAT_KICK | MUSIC_BEAT_HIHAT, 0}};
const Aos4Aos3F32 g_music_melody = {{{{NOTE_F.data[4], NOTE_GS.data[4], NOTE_C.data[5]}}, {{NOTE_G.data[4], NOTE_AS.data[4], NOTE_D.data[5]}}, {{NOTE_F.data[4], NOTE_GS.data[4], NOTE_C.data[5]}}, {{NOTE_G.data[4], NOTE_B.data[4], NOTE_D.data[5]}}}};
const Aos16F32 g_music_synth = {{NOTE_F.data[(6 - 1)], NOTE_G.data[(6 - 1)], NOTE_C.data[(6 - 1)], 0.0f, NOTE_DS.data[(6 - 1)], NOTE_G.data[(6 - 1)], NOTE_C.data[(6 - 1)], 0.0f, NOTE_F.data[(6 - 1)], NOTE_G.data[(6 - 1)], NOTE_C.data[(6 - 1)], 0.0f, NOTE_C.data[(6 - 1)], NOTE_G.data[(6 - 1)], NOTE_C.data[(6 - 1)], 0.0f}};
const Aos64F32 g_music_bass = {{NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_C.data[3], NOTE_C.data[3], NOTE_C.data[3], NOTE_C.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_D.data[3], NOTE_D.data[3], NOTE_D.data[3], NOTE_D.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_C.data[3], NOTE_C.data[3], NOTE_C.data[3], NOTE_C.data[3], NOTE_F.data[3], NOTE_F.data[3], 0.0f, NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_F.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_G.data[3], NOTE_AS.data[3], NOTE_AS.data[3], NOTE_AS.data[3], NOTE_AS.data[3]}};
const I32 GLYPH_WIDTH = 5;
const I32 GLYPH_HEIGHT = 6;
const I32 GLYPH_ASCII_FIRST = 32;
const Aos95U32 g_glyphs = {{0, 134353028, 10570, 368389098, 150616254, 866266720, 781506726, 4228, 272765064, 71438466, 10631296, 4657152, 71434240, 458752, 207618048, 35791360, 490395438, 1044518084, 1042424366, 488124943, 554682504, 488127551, 488080460, 35791391, 488159790, 554649150, 207624384, 71307264, 272699648, 14694400, 71569472, 134361646, 1008662062, 589284676, 521715247, 1007715886, 521717295, 1041284159, 34651199, 488408126, 588840497, 1044517023, 211034399, 588553521, 1041269793, 588961467, 597481073, 488162862, 35112495, 820692526, 580372015, 487856686, 138547359, 488162865, 138757681, 928699953, 581046609, 138547537, 1042424351, 406982796, 545392672, 205656198, 17732, 3187671040, 130, 479703040, 244620321, 470857728, 479508744, 1008715200, 1109466188, 1317479726, 311729185, 203489344, 2353139716, 307336481, 203491394, 593144832, 311729152, 211064832, 1108583718, 1887905070, 34904064, 243494912, 203504706, 244622336, 73704448, 358269952, 910322688, 1317479721, 505560064, 407050380, 138547332, 205926534, 448512}};

// VECC function definitions

static void spawn_item(Aos2F32 pos, I32 powerup) {
	for (I32 i = 0; i < VECC_LEN(g_items.data); i = i + 1) {
		Item item = g_items.data[i];
		if (item.powerup == -1) {
			play_sound(SOUND_SPAWN);
			item.pos = pos;
			item.powerup = powerup;
			item.timer = 0.0f;
			g_items.data[i] = item;
			break;
		};
	};
}

static void spawn_effect(Aos2F32 pos, F32 rad, F32 dur, Aos4U8 color) {
	for (I32 i = 0; i < VECC_LEN(g_effects.data); i = i + 1) {
		V8Effect effect = g_effects.data[i];
		V8B32 cond = v8f32_gt(effect.timer, effect.dur);
		if (v8b32_reduce_any(cond)) {
			V8B32 vecc_mask4 = v8i32_eq(vector_index, v8i32_set1(u8_count_trailing_zeros(v8b32_to_bitmask(cond)))); { // vector if
				g_effects.data[i].pos.data[0] = v8f32_blend(g_effects.data[i].pos.data[0], v8f32_set1(pos.data[0]), vecc_mask4);
				g_effects.data[i].pos.data[1] = v8f32_blend(g_effects.data[i].pos.data[1], v8f32_set1(pos.data[1]), vecc_mask4);
				g_effects.data[i].rad = v8f32_blend(g_effects.data[i].rad, v8f32_set1(rad), vecc_mask4);
				g_effects.data[i].timer = v8f32_blend(g_effects.data[i].timer, v8f32_set1(0.0f), vecc_mask4);
				g_effects.data[i].dur = v8f32_blend(g_effects.data[i].dur, v8f32_set1(dur), vecc_mask4);
				g_effects.data[i].color.data[0] = v8u8_blend(g_effects.data[i].color.data[0], v8u8_set1(color.data[0]), vecc_mask4);
				g_effects.data[i].color.data[1] = v8u8_blend(g_effects.data[i].color.data[1], v8u8_set1(color.data[1]), vecc_mask4);
				g_effects.data[i].color.data[2] = v8u8_blend(g_effects.data[i].color.data[2], v8u8_set1(color.data[2]), vecc_mask4);
				g_effects.data[i].color.data[3] = v8u8_blend(g_effects.data[i].color.data[3], v8u8_set1(color.data[3]), vecc_mask4);
				break;
			};
		};
	};
}

static void reset_game() {
	player.pos = aos2f32_div({{(F32)RESOLUTION_X, (F32)RESOLUTION_Y}}, aos2f32_set1(2.0f));
	player.vel = aos2f32_set1(0.0f);
	player.gun_timer = 0.0f;
	player.powerup_timer = {{0.0f, 0.0f, 0.0f}};
	player.dir = {{1.0f, 0.0f}};
	for (I32 i = 0; i < VECC_LEN(g_items.data); i = i + 1) {
		g_items.data[i].powerup = -1;
	};
	for (I32 i = 0; i < VECC_LEN(g_bullets.data); i = i + 1) {
		g_bullets.data[i].used = b8_false;
	};
	for (I32 i = 0; i < VECC_LEN(g_enemies.data); i = i + 1) {
		g_enemies.data[i].pos = aos2f32_neg(aos2f32_set1(100.0f));
		g_enemies.data[i].state = ENEMY_STATE_DEAD;
	};
	for (I32 i = 0; i < VECC_LEN(g_effects.data); i = i + 1) {
		g_effects.data[i].dur = v8f32_neg(v8f32_set1(1.0f));
	};
	for (I32 i = 0; i < SOUND_NUM; i = i + 1) {
		g_sound_sample.data[i] = 100000;
	};
	play_sound(SOUND_BEGIN);
	g_enemy_spawn_timer = -2.0f;
	g_game_timer = 0.0f;
	g_shake = 30.0f;
}

void compute_frame(V8U32* framebuffer, Aos2I32 resolution, F32 time, F32 delta, I32 frame, U32 keys, F32* audio_buffer, I32 audio_samples) {
	if (frame == 0) {
		reset_game();
	};
	const I32 num_pixel_blocks = (resolution.data[0] * resolution.data[1]) / vector_width;
	B8 end_game = false;
	B32 should_hit_pause = g_hit_pause > 0.0f;
	g_hit_pause = g_hit_pause - delta;
	if (should_hit_pause) {
		for (I32 i = 0; i < num_pixel_blocks; i = i + 1) {
			const V8U32 c = framebuffer[i];
			framebuffer[i] = v8u32_or(c, v8u32_set1(color_to_u32({{10, 10, 10, 0}})));
		};
	} else {
		g_game_timer = g_game_timer + delta;
		U32 clear_mask = (*(U32*)&delta);
		clear_mask = ~clear_mask;
		for (I32 i = 0; i < num_pixel_blocks; i = i + 1) {
			const V8U32 c = framebuffer[i];
			framebuffer[i] = v8u32_sl(c, 5);
		};
		if (g_game_timer < 4.0f) {
			draw_text(framebuffer, resolution, {"              120+", 18}, {{28, 60}}, 12303291);
			draw_text(framebuffer, resolution, {"         BY JAKUB TOMSU", 23}, {{28, 70}}, 3355443);
			draw_text(framebuffer, resolution, {"           controls", 19}, {{28, 150 + 10}}, 7829367);
			draw_text(framebuffer, resolution, {"          MOVE     ARROW KEYS", 29}, {{28, 150 + 30}}, 12303291);
			draw_text(framebuffer, resolution, {" SHOOT FORWARD     X", 20}, {{28, 150 + 40}}, 12303291);
			draw_text(framebuffer, resolution, {"SHOOT BACKWARD     Z", 20}, {{28, 150 + 50}}, 12303291);
		};
		g_camera = {{(I32)f32_round((rand_f32() - 0.5f) * g_shake), (I32)f32_round((rand_f32() - 0.5f) * g_shake)}};
		g_shake = f32_max(0.0f, g_shake - (delta * 50.0f));
		for (I32 i = 0; i < VECC_LEN(g_enemies.data); i = i + 1) {
			Enemy enemy = g_enemies.data[i];
			if (enemy.state != ENEMY_STATE_DEAD) {
				continue;
			};
			draw_octagon(framebuffer, resolution, aos2f32_to_aos2i32(enemy.pos), 5, 6, {{50, 20, 30, 0}});
		};
		for (I32 i = 0; i < VECC_LEN(g_items.data); i = i + 1) {
			Item item = g_items.data[i];
			if (item.powerup == -1) {
				continue;
			};
			item.timer = item.timer + delta;
			if (item.timer > 8.0f) {
				item.powerup = -1;
			};
			if (length2(aos2f32_sub(item.pos, player.pos)) < (10.0f * 10.0f)) {
				if (player.powerup_timer.data[item.powerup] < 0.0f) {
					player.powerup_timer.data[item.powerup] = 0.0f;
				};
				player.powerup_timer.data[item.powerup] = player.powerup_timer.data[item.powerup] + 7.0f;
				play_sound(SOUND_PICKUP);
				item.powerup = -1;
			};
			g_items.data[i] = item;
			F32 rad = f32_round(2.2f + (f32_sin((time + (F32)(i * 13)) * 8.0f) * 0.69999999f));
			Aos4U8 color = {0};
			if (item.powerup == PLAYER_POWERUP_FAST_FIRE) {
				color = POWERUP_FAST_FIRE_COLOR;
			};
			if (item.powerup == PLAYER_POWERUP_SHOTGUN) {
				color = POWERUP_SHOTGUN_COLOR;
			};
			if (item.powerup == PLAYER_POWERUP_EXPLOSIVE) {
				color = POWERUP_EXPLOSIVE_COLOR;
			};
			if (item.timer > 6.0f) {
				if (f32_sin(item.timer * 30.0f) > 0.0f) {
					color = {{0, 0, 0, 0}};
				};
				rad = 3.0f;
			};
			draw_octagon(framebuffer, resolution, aos2f32_to_aos2i32(item.pos), (I32)rad, 100, color);
		};
		F32 max_enemy_damage_timer = 0.0f;
		I32 oldest_corpse = -1;
		for (I32 i = 0; i < VECC_LEN(g_enemies.data); i = i + 1) {
			Enemy enemy = g_enemies.data[i];
			enemy.damage_timer = enemy.damage_timer + delta;
			if (enemy.state == ENEMY_STATE_DEAD) {
				if (enemy.damage_timer >= max_enemy_damage_timer) {
					max_enemy_damage_timer = enemy.damage_timer;
					oldest_corpse = i;
				};
				g_enemies.data[i] = enemy;
				continue;
			};
			enemy.vel = aos2f32_add(enemy.vel, aos2f32_mul(normalize(aos2f32_sub(player.pos, enemy.pos)), aos2f32_set1(delta * (enemy.speed * 5.0f))));
			enemy.vel = aos2f32_mul(normalize(enemy.vel), aos2f32_set1(f32_clamp(length(enemy.vel), 0.0f, enemy.speed)));
			enemy.pos = aos2f32_add(enemy.pos, aos2f32_mul(enemy.vel, aos2f32_set1(delta)));
			F32 rad = (F32)enemy.size;
			if (length2(aos2f32_sub(enemy.pos, player.pos)) < (rad * rad)) {
				end_game = b8_true;
			};
			if (enemy.health <= 0.0f) {
				enemy.state = ENEMY_STATE_DEAD;
				play_sound(SOUND_KILL);
				spawn_effect(enemy.pos, 9.0f, 0.05f, {{255, 255, 255, 255}});
				g_shake = g_shake + 5.0f;
				g_hit_pause = 0.02f;
				U32 p = 0;
				if (g_game_timer < 30.0f) {
					p = rand_u32() % 8;
				} else {
					if (g_game_timer < 60.0f) {
						p = rand_u32() % 12;
					} else {
						p = rand_u32() % 16;
					};
				};
				if (p < 3) {
					spawn_item(enemy.pos, (I32)p);
				};
			};
			Aos4U8 color = {0};
			color = ENEMY_COLOR_NORMAL;
			if (enemy.kind == 1) {
				color = ENEMY_COLOR_FAST;
			};
			if (enemy.kind == 2) {
				color = ENEMY_COLOR_BIG;
			};
			if (enemy.damage_timer < 0.05f) {
				color = {{255, 255, 255, 255}};
			};
			Aos2F32 enemy_pos = enemy.pos;
			draw_octagon(framebuffer, resolution, aos2f32_to_aos2i32(enemy_pos), (I32)enemy.size, (I32)(enemy.size + 1), color);
			g_enemies.data[i] = enemy;
		};
		if (oldest_corpse == -1) {
			oldest_corpse = (I32)rand_u32() % VECC_LEN(g_enemies.data);
		};
		g_enemy_spawn_timer = g_enemy_spawn_timer + delta;
		const F32 spawn_rate = 0.1f + (1.2f * f32_max(0.0f, 1.0f - (g_game_timer / GAME_MAX_TIME)));
		if ((g_enemy_spawn_timer > spawn_rate) & (oldest_corpse != -1)) {
			g_enemy_spawn_timer = 0.0f;
			Enemy enemy = g_enemies.data[oldest_corpse];
			enemy.state = ENEMY_STATE_ALIVE;
			const F32 RAD = 0.0f;
			if ((rand_u32() & 1) == 0) {
				if ((rand_u32() & 1) == 0) {
					enemy.pos.data[0] = -RAD;
				} else {
					enemy.pos.data[0] = (F32)RESOLUTION_X + RAD;
				};
				enemy.pos.data[1] = (F32)((I32)rand_u32() % RESOLUTION_Y);
			} else {
				if ((rand_u32() & 1) == 0) {
					enemy.pos.data[1] = -RAD;
				} else {
					enemy.pos.data[1] = (F32)RESOLUTION_Y + RAD;
				};
				enemy.pos.data[0] = (F32)((I32)rand_u32() % RESOLUTION_X);
			};
			spawn_effect(enemy.pos, 10.0f, 0.029999999f, {{200, 0, 150, 255}});
			spawn_effect(enemy.pos, 7.0f, 0.1f, {{255, 0, 180, 255}});
			if ((g_game_timer > 10.0f) & ((rand_u32() % 4) == 0)) {
				if ((g_game_timer > 30.0f) & ((rand_u32() % 6) == 0)) {
					enemy.size = 14;
					enemy.health = 18.0f;
					enemy.speed = 6.0f;
					enemy.kind = 2;
				} else {
					enemy.size = 8;
					enemy.health = 6.0f;
					enemy.speed = 8.0f;
					enemy.kind = 2;
				};
			} else {
				if ((g_game_timer > 5.0f) & ((rand_u32() % 3) == 0)) {
					enemy.size = 5;
					enemy.health = 0.5f;
					enemy.speed = 30.0f;
					enemy.kind = 1;
				} else {
					enemy.size = 6;
					enemy.health = 2.0f;
					enemy.speed = 20.0f;
					enemy.kind = 0;
				};
			};
			g_enemies.data[oldest_corpse] = enemy;
		};
		for (I32 i = 0; i < VECC_LEN(g_effects.data); i = i + 1) {
			V8Effect effect = g_effects.data[i];
			effect.timer = v8f32_add(effect.timer, v8f32_set1(delta));
			V8B32 vecc_mask53 = v8f32_lt(effect.timer, effect.dur); { // vector if
				U8 bitmask = v8b32_to_bitmask(vecc_mask53);
				for (I32 j = 0; j < vector_width; j = j + 1) {
					if ((bitmask & (1 << j)) != 0) {
						Effect scal = v8effect_extract(effect, j);
						draw_octagon(framebuffer, resolution, aos2f32_to_aos2i32(scal.pos), (I32)scal.rad, (I32)(scal.rad * 1.5f), scal.color);
					};
				};
			};
			g_effects.data[i] = effect;
		};
		{
			Aos3B8 powerups = {0};
			for (I32 i = 0; i < POWERUP_NUM; i = i + 1) {
				player.powerup_timer.data[i] = player.powerup_timer.data[i] - delta;
				if (player.powerup_timer.data[i] > 0.0f) {
					powerups.data[i] = b8_true;
				};
			};
			Aos2F32 dir = {0};
			B8 moving = false;
			if ((keys & KEY_LEFT_BIT) != 0) {
				dir.data[0] = dir.data[0] + -1.0f;
			};
			if ((keys & KEY_RIGHT_BIT) != 0) {
				dir.data[0] = dir.data[0] + 1.0f;
			};
			if ((keys & KEY_UP_BIT) != 0) {
				dir.data[1] = dir.data[1] + -1.0f;
			};
			if ((keys & KEY_DOWN_BIT) != 0) {
				dir.data[1] = dir.data[1] + 1.0f;
			};
			moving = (B8)(length2(dir) > 0.0f);
			F32 cooldown_time = 0.1f;
			I32 num_shots = 1;
			F32 shot_spread = 0.25f;
			U8 bullet_level = 0;
			F32 bullet_speed = 300.0f;
			if (powerups.data[PLAYER_POWERUP_FAST_FIRE]) {
				cooldown_time = cooldown_time * 0.4f;
				bullet_speed = bullet_speed * 1.5f;
				bullet_level = bullet_level + 1;
			};
			if (powerups.data[PLAYER_POWERUP_SHOTGUN]) {
				cooldown_time = cooldown_time * 2.0f;
				num_shots = num_shots * 4;
				shot_spread = shot_spread * 3.0f;
				bullet_level = bullet_level + 1;
			};
			if (powerups.data[PLAYER_POWERUP_EXPLOSIVE]) {
				bullet_speed = bullet_speed * 0.69999999f;
				cooldown_time = cooldown_time * 2.0f;
				bullet_level = bullet_level + 1;
			};
			player.gun_timer = player.gun_timer + delta;
			F32 shoot_dir = 1.0f;
			B32 shooting = false;
			if ((keys & KEY_X_BIT) != 0) {
				shoot_dir = 1.0f;
				shooting = b32_true;
			};
			if ((keys & KEY_Z_BIT) != 0) {
				shoot_dir = -1.0f;
				shooting = b32_true;
			};
			if (shooting & (player.gun_timer > cooldown_time)) {
				player.gun_timer = 0.0f;
				player.vel = aos2f32_sub(player.vel, aos2f32_mul(player.dir, aos2f32_mul(aos2f32_set1(38.0f), aos2f32_set1(shoot_dir))));
				I32 bullet_num = 0;
				g_shake = 1.0f;
				spawn_effect(aos2f32_add(player.pos, aos2f32_mul(player.dir, aos2f32_mul(aos2f32_set1(6.0f), aos2f32_set1(shoot_dir)))), 3.0f, 0.0099999998f, {{0, 255, 255, 0}});
				play_sound(SOUND_SHOOT);
				for (I32 i = 0; i < VECC_LEN(g_bullets.data); i = i + 1) {
					if (!g_bullets.data[i].used) {
						Aos2F32 bdir = aos2f32_mul(player.dir, aos2f32_set1(shoot_dir));
						bdir.data[0] = bdir.data[0] + ((rand_f32() - 0.5f) * shot_spread);
						bdir.data[1] = bdir.data[1] + ((rand_f32() - 0.5f) * shot_spread);
						bdir = normalize(bdir);
						g_bullets.data[i] = {b8_true, aos2f32_add(player.pos, aos2f32_mul(player.dir, aos2f32_mul(aos2f32_set1(6.0f), aos2f32_set1(shoot_dir)))), aos2f32_mul(bdir, aos2f32_set1(bullet_speed)), 0.0f, bullet_level, powerups.data[PLAYER_POWERUP_EXPLOSIVE]};
						bullet_num = bullet_num + 1;
						if (bullet_num == num_shots) {
							break;
						};
					};
				};
			};
			if (moving) {
				if (!shooting) {
					player.dir = dir;
				};
			};
			if (moving) {
				player.particle_timer = player.particle_timer + delta;
				if (player.particle_timer > 0.15f) {
					player.particle_timer = player.particle_timer - 0.15f;
					play_sound(SOUND_WALK);
					spawn_effect(player.pos, 1.0f, rand_f32() * 8.0f, {{100, 100, 100, 0}});
				};
			};
			player.vel = aos2f32_mul(player.vel, aos2f32_set1(0.89999998f));
			player.vel = aos2f32_add(player.vel, aos2f32_mul(dir, aos2f32_set1(delta * 1000.0f)));
			player.pos = aos2f32_add(player.pos, aos2f32_mul(player.vel, aos2f32_set1(delta)));
			const F32 RAD = 5.0f;
			player.pos.data[0] = f32_clamp(player.pos.data[0], RAD, (F32)RESOLUTION_X - RAD);
			player.pos.data[1] = f32_clamp(player.pos.data[1], RAD, (F32)RESOLUTION_Y - RAD);
			Aos2F32 player_pos = player.pos;
			player_pos.data[1] = player_pos.data[1] - f32_round((0.5f + (0.5f * f32_sin(time * 30.0f))) * f32_clamp(length(player.vel), 0.0f, 1.0f));
			draw_octagon(framebuffer, resolution, aos2f32_to_aos2i32(player_pos), 3, 5, {{255, 150, 0, 0}});
			Aos2I32 gun_pos = aos2f32_to_aos2i32(player.pos);
			gun_pos.data[0] = gun_pos.data[0] + (I32)(((player.dir.data[0] * shoot_dir) * 3.0f) * f32_min(player.gun_timer * 10.0f, 1.0f));
			gun_pos.data[1] = gun_pos.data[1] + (I32)(((player.dir.data[1] * shoot_dir) * 3.0f) * f32_min(player.gun_timer * 10.0f, 1.0f));
			gun_pos.data[1] = gun_pos.data[1] + 1;
			Aos2I32 gun_size = {{7, 2}};
			if (player.dir.data[0] == 0.0f) {
				gun_size = {{gun_size.data[1] + 1, gun_size.data[0] - 1}};
			};
			draw_rect(framebuffer, resolution, aos2i32_sub(aos2i32_sub(gun_pos, {{gun_size.data[0] / 2, gun_size.data[1] / 2}}), g_camera), gun_size, {{255, 255, 255, 255}});
		};
		for (I32 i = 0; i < VECC_LEN(g_bullets.data); i = i + 1) {
			Bullet bullet = g_bullets.data[i];
			if (bullet.timer > 0.4f) {
				bullet.timer = 0.0f;
				bullet.used = b8_false;
			};
			if (bullet.used) {
				bullet.timer = bullet.timer + delta;
				const Aos2F32 move = aos2f32_mul(bullet.vel, aos2f32_set1(delta));
				const Aos2F32 move_dir = normalize(move);
				F32 tmin = length(move);
				I32 hit_enemy = -1;
				for (I32 ei = 0; ei < VECC_LEN(g_enemies.data); ei = ei + 1) {
					const Enemy enemy = g_enemies.data[ei];
					if (enemy.state != ENEMY_STATE_ALIVE) {
						continue;
					};
					const Hit hit = intersect_ray_aabb(bullet.pos, move_dir, aos2f32_sub(enemy.pos, aos2f32_set1((F32)(enemy.size + 1))), aos2f32_add(enemy.pos, aos2f32_set1((F32)(enemy.size + 1))));
					if (hit.hit & (B8)(hit.tmin < tmin)) {
						tmin = hit.tmin;
						hit_enemy = ei;
					};
				};
				if (hit_enemy == -1) {
					bullet.pos = aos2f32_add(bullet.pos, move);
				} else {
					bullet.pos = aos2f32_add(bullet.pos, aos2f32_mul(move_dir, aos2f32_set1(tmin)));
					bullet.used = b8_false;
					if (bullet.explode) {
						spawn_effect(bullet.pos, 32.0f, 0.0099999998f, {{0, 255, 255, 0}});
						spawn_effect(bullet.pos, 22.0f, 0.05f, {{255, 255, 255, 0}});
						g_hit_pause = 0.09f;
						play_sound(SOUND_EXPLOSION);
						for (I32 ei = 0; ei < VECC_LEN(g_enemies.data); ei = ei + 1) {
							Enemy enemy = g_enemies.data[ei];
							if (enemy.state != ENEMY_STATE_ALIVE) {
								continue;
							};
							if (length2(aos2f32_sub(enemy.pos, bullet.pos)) < (32.0f * 32.0f)) {
								enemy.health = enemy.health - 3.0f;
								enemy.damage_timer = 0.0f;
								enemy.vel = aos2f32_set1(0.0f);
								g_enemies.data[ei] = enemy;
							};
						};
					} else {
						spawn_effect(bullet.pos, 4.0f, 0.1f, {{0, 255, 255, 0}});
					};
					play_sound(SOUND_HIT);
					Enemy enemy = g_enemies.data[hit_enemy];
					enemy.health = enemy.health - 1.0f;
					enemy.damage_timer = 0.0f;
					enemy.vel = bullet.vel;
					g_enemies.data[hit_enemy] = enemy;
				};
				draw_octagon(framebuffer, resolution, aos2f32_to_aos2i32(bullet.pos), 2, 2 + (I32)bullet.level, {{0, 255, 255, 0}});
			};
			g_bullets.data[i] = bullet;
		};
		if (g_game_timer < GAME_MAX_TIME) {
			draw_rect(framebuffer, resolution, {{0, 1}}, {{RESOLUTION_X - 1, 1}}, {{100, 100, 100, 100}});
			draw_rect(framebuffer, resolution, {{0, 1}}, {{(I32)((F32)RESOLUTION_X * (1.0f - (g_game_timer / GAME_MAX_TIME))), 1}}, {{255, 255, 255, 255}});
		} else {
			draw_rect(framebuffer, resolution, {{0, 1}}, {{RESOLUTION_X - 1, 1}}, {{255, 0, 0, 0}});
		};
		draw_rect(framebuffer, resolution, {{1, RESOLUTION_Y - 5}}, {{i32_max(0, (I32)(3.0f * f32_ceil(player.powerup_timer.data[PLAYER_POWERUP_FAST_FIRE]))), 3}}, POWERUP_FAST_FIRE_COLOR);
		draw_rect(framebuffer, resolution, {{1, RESOLUTION_Y - 10}}, {{i32_max(0, (I32)(3.0f * f32_ceil(player.powerup_timer.data[PLAYER_POWERUP_SHOTGUN]))), 3}}, POWERUP_SHOTGUN_COLOR);
		draw_rect(framebuffer, resolution, {{1, RESOLUTION_Y - 15}}, {{i32_max(0, (I32)(3.0f * f32_ceil(player.powerup_timer.data[PLAYER_POWERUP_EXPLOSIVE]))), 3}}, POWERUP_EXPLOSIVE_COLOR);
	};
	for (I32 audio_sample = 0; audio_sample < audio_samples; audio_sample = audio_sample + 1) {
		F32 begin_t = sample_t(g_sound_sample.data[SOUND_BEGIN]);
		F32 walk_t = sample_t(g_sound_sample.data[SOUND_WALK]);
		F32 hit_t = sample_t(g_sound_sample.data[SOUND_HIT]);
		F32 shoot_t = sample_t(g_sound_sample.data[SOUND_SHOOT]);
		F32 explosion_t = sample_t(g_sound_sample.data[SOUND_EXPLOSION]);
		F32 kill_t = sample_t(g_sound_sample.data[SOUND_KILL]);
		F32 pickup_t = sample_t(g_sound_sample.data[SOUND_PICKUP]);
		F32 spawn_t = sample_t(g_sound_sample.data[SOUND_SPAWN]);
		F32 hit = wave_square(hit_t * (200.0f - (hit_t * 100.0f)));
		hit = hit + wave_sin(hit_t * (600.0f - (hit_t * 500.0f)));
		hit = hit + wave_noise(hit_t * 600.0f);
		hit = hit * (f32_max(0.0f, 1.0f - (hit_t * 5.0f)) * 2.0f);
		F32 begin = wave_sin(begin_t * (400.0f + (begin_t * 500.0f)));
		begin = begin + wave_triangle(begin_t * (200.0f + (begin_t * 200.0f)));
		begin = begin + (wave_saw(begin_t * (800.0f + (begin_t * 800.0f))) * (f32_max(0.0f, 1.0f - begin_t) * 0.2f));
		begin = begin * f32_max(0.0f, 1.0f - begin_t);
		F32 walk = wave_noise(walk_t * (600.0f + (g_sound_rand.data[SOUND_WALK] * 300.0f)));
		walk = walk + wave_saw(walk_t * 200.0f);
		walk = walk * (f32_max(0.0f, 1.0f - (walk_t * 50.0f)) * 0.5f);
		F32 shoot = 0.0f;
		shoot = shoot + (wave_noise(shoot_t * (400.0f + (g_sound_rand.data[SOUND_SHOOT] * 100.0f))) * f32_max(0.0f, 1.0f - (shoot_t * 10.0f)));
		shoot = shoot + (wave_noise(shoot_t * 200.0f) * f32_max(0.0f, 0.5f - (shoot_t * 2.0f)));
		shoot = shoot - (wave_saw(shoot_t * (200.0f + (shoot_t * 500.0f))) * f32_max(0.0f, 1.0f - (shoot_t * 50.0f)));
		shoot = shoot * 2.0f;
		F32 explosion = 0.0f;
		explosion = explosion + (wave_noise(explosion_t * (200.0f + (g_sound_rand.data[SOUND_EXPLOSION] * 400.0f))) * f32_max(0.0f, 1.0f - explosion_t));
		explosion = explosion + (wave_noise(explosion_t * (500.0f + (g_sound_rand.data[SOUND_EXPLOSION] * 400.0f))) * f32_max(0.0f, 1.0f - (explosion_t * 10.0f)));
		explosion = explosion * 4.0f;
		F32 kill = wave_square(kill_t * (600.0f - (kill_t * 300.0f)));
		kill = kill + wave_noise(kill_t * 1000.0f);
		kill = kill * f32_max(0.0f, 1.0f - (kill_t * 3.0f));
		F32 pickup = 0.0f;
		pickup = pickup + wave_saw(pickup_t * (400.0f + (pickup_t * 500.0f)));
		pickup = pickup + wave_triangle(pickup_t * (800.0f + (pickup_t * 400.0f)));
		pickup = pickup * f32_max(0.0f, 1.0f - (pickup_t * 2.0f));
		F32 spawn = 0.0f;
		spawn = spawn + wave_sin(spawn_t * (500.0f + (spawn_t * 3000.0f)));
		spawn = spawn + wave_saw(spawn_t * (900.0f + (spawn_t * 400.0f)));
		spawn = spawn * (f32_max(0.0f, 1.0f - (spawn_t * 6.0f)) * 2.0f);
		F32 music = 0.0f;
		{
			const F32 t = sample_t(g_audio_sample);
			const I32 BEAT_SAMPLES = AUDIO_SAMPLE_RATE / 12;
			if (g_music_beat_sample >= BEAT_SAMPLES) {
				g_music_beat_sample = g_music_beat_sample - BEAT_SAMPLES;
				g_music_beat_index = g_music_beat_index + 1;
				g_music_beat_index = g_music_beat_index % VECC_LEN(g_music_beat.data);
			};
			F32 beat_t = (F32)g_music_beat_sample / (F32)BEAT_SAMPLES;
			U8 beat = g_music_beat.data[g_music_beat_index];
			F32 beat_s = sample_t(g_music_beat_sample);
			F32 kick = wave_triangle(beat_s * (200.0f - (beat_t * 100.0f))) * f32_max(0.0f, 1.0f - beat_t);
			F32 snare = wave_noise(beat_s * (18000.0f - (beat_t * 2000.0f))) * f32_max(0.0f, 1.0f - ((beat_t * 2.0f) * (beat_t * 2.0f)));
			F32 hihat = wave_noise(beat_s * (20000.0f + (beat_t * 5000.0f))) * f32_max(0.0f, 1.0f - (beat_t * 4.0f));
			if ((MUSIC_BEAT_KICK & beat) == 0) {
				kick = 0.0f;
			};
			if ((MUSIC_BEAT_SNARE & beat) == 0) {
				snare = 0.0f;
			};
			if ((MUSIC_BEAT_HIHAT & beat) == 0) {
				hihat = 0.0f;
			};
			const I32 MELODY_SAMPLES = BEAT_SAMPLES * 16;
			if (g_music_melody_sample >= MELODY_SAMPLES) {
				g_music_melody_sample = g_music_melody_sample - MELODY_SAMPLES;
				g_music_melody_index = g_music_melody_index + 1;
				g_music_melody_index = g_music_melody_index % VECC_LEN(g_music_melody.data);
			};
			F32 melody_t = (F32)g_music_melody_sample / (F32)MELODY_SAMPLES;
			F32 melody_s = sample_t(g_music_melody_sample);
			Aos3F32 melody_chord = g_music_melody.data[g_music_melody_index];
			F32 melody = 0.0f;
			melody = melody + wave_sin(melody_s * melody_chord.data[0]);
			melody = melody + wave_sin(melody_s * melody_chord.data[1]);
			melody = melody + wave_sin(melody_s * melody_chord.data[2]);
			melody = melody * (1.0f - melody_t);
			const I32 BASS_SAMPLES = BEAT_SAMPLES * 2;
			if (g_music_bass_sample >= BASS_SAMPLES) {
				g_music_bass_sample = g_music_bass_sample - BASS_SAMPLES;
				g_music_bass_index = g_music_bass_index + 1;
				g_music_bass_index = g_music_bass_index % VECC_LEN(g_music_bass.data);
			};
			F32 bass_t = (F32)g_music_bass_sample / (F32)BASS_SAMPLES;
			F32 bass_s = sample_t(g_music_bass_sample);
			F32 bass_note = g_music_bass.data[g_music_bass_index];
			F32 bass = wave_triangle(bass_s * bass_note) * (1.0f - bass_t);
			const I32 SYNTH_SAMPLES = BEAT_SAMPLES * 16;
			if (g_music_synth_sample >= SYNTH_SAMPLES) {
				g_music_synth_sample = g_music_synth_sample - SYNTH_SAMPLES;
				g_music_synth_index = g_music_synth_index + 1;
				g_music_synth_index = g_music_synth_index % VECC_LEN(g_music_synth.data);
			};
			F32 synth_t = (F32)g_music_synth_sample / (F32)SYNTH_SAMPLES;
			F32 synth_s = sample_t(g_music_synth_sample);
			F32 synth_note = g_music_synth.data[g_music_synth_index];
			F32 synth = wave_triangle(synth_s * synth_note) * (((1.0f - synth_t) * (1.0f - synth_t)) * (1.0f - synth_t));
			synth = synth * f32_clamp((synth_t - 0.125f) * 100.0f, 0.0f, 1.0f);
			kick = kick * f32_min(1.0f, t);
			snare = snare * f32_min(1.0f, t * 0.1f);
			hihat = hihat * f32_min(1.0f, t * 0.5f);
			melody = melody * f32_min(1.0f, t * 0.5f);
			bass = bass * f32_min(1.0f, t * 0.1f);
			synth = synth * f32_min(1.0f, t * 0.1f);
			music = music + (kick * 2.0f);
			music = music + (snare * 2.0f);
			music = music + (hihat * 0.5f);
			music = music + (melody * 0.5f);
			music = music + (bass * 2.0f);
			music = music + (synth * 2.0f);
		};
		F32 sample = 0.0f;
		sample = sample + begin;
		sample = sample + walk;
		sample = sample + hit;
		sample = sample + shoot;
		sample = sample + explosion;
		sample = sample + kill;
		sample = sample + pickup;
		sample = sample + spawn;
		sample = sample + music;
		sample = sample * 0.05f;
		audio_buffer[audio_sample] = sample;
		for (I32 i = 0; i < SOUND_NUM; i = i + 1) {
			g_sound_sample.data[i] = g_sound_sample.data[i] + 1;
		};
		g_audio_sample = g_audio_sample + 1;
		g_music_beat_sample = g_music_beat_sample + 1;
		g_music_melody_sample = g_music_melody_sample + 1;
		g_music_bass_sample = g_music_bass_sample + 1;
		g_music_synth_sample = g_music_synth_sample + 1;
	};
	if (end_game) {
		reset_game();
		for (I32 i = 0; i < num_pixel_blocks; i = i + 1) {
			framebuffer[i] = v8u32_set1(0);
		};
	};
}

static void draw_rect(V8U32* framebuffer, Aos2I32 resolution, Aos2I32 pos, Aos2I32 size, Aos4U8 color) {
	const U32 col = color_to_u32(color);
	const I32 x_end = pos.data[0] + size.data[0];
	const Aos2I32 x_range = {{i32_clamp(pos.data[0], 0, resolution.data[0]) / vector_width, ((i32_clamp(x_end, 0, resolution.data[0]) + vector_width) - 1) / vector_width}};
	const Aos2I32 y_range = {{i32_clamp(pos.data[1], 0, resolution.data[1]), i32_clamp(pos.data[1] + size.data[1], 0, resolution.data[1])}};
	for (I32 y = y_range.data[0]; y < y_range.data[1]; y = y + 1) {
		const I32 y_offset = y * (resolution.data[0] / vector_width);
		for (I32 xv = x_range.data[0]; xv < x_range.data[1]; xv = xv + 1) {
			const V8I32 x = v8i32_add(vector_index, v8i32_set1(xv * vector_width));
			V8B32 vecc_mask5 = v8i32_gt(x, v8i32_set1(pos.data[0])); { // vector if
				V8B32 vecc_mask6 = v8b32_and(vecc_mask5, v8i32_lt(x, v8i32_set1(x_end))); { // vector if
					framebuffer[(y_offset + xv)] = v8u32_blend(framebuffer[(y_offset + xv)], v8u32_set1(col), vecc_mask6);
				};
			};
		};
	};
}

static void draw_octagon(V8U32* framebuffer, Aos2I32 resolution, Aos2I32 pos, I32 size, I32 rad, Aos4U8 color) {
	pos = aos2i32_sub(pos, g_camera);
	const U32 col = color_to_u32(color);
	const I32 x_start = pos.data[0] - size;
	const I32 x_end = pos.data[0] + size;
	const Aos2I32 x_range = {{i32_clamp(x_start, 0, resolution.data[0]) / vector_width, ((i32_clamp(x_end, 0, resolution.data[0]) + vector_width) - 1) / vector_width}};
	const Aos2I32 y_range = {{i32_clamp(pos.data[1] - (size - 1), 0, resolution.data[1]), i32_clamp(pos.data[1] + size, 0, resolution.data[1])}};
	for (I32 y = y_range.data[0]; y < y_range.data[1]; y = y + 1) {
		const I32 y_offset = y * (resolution.data[0] / vector_width);
		for (I32 xv = x_range.data[0]; xv < x_range.data[1]; xv = xv + 1) {
			const V8I32 x = v8i32_add(vector_index, v8i32_set1(xv * vector_width));
			const Aos2V8I32 rel = aos2v8i32_sub({{x, v8i32_set1(y)}}, aos2v8i32_set_scalar(pos));
			const V8I32 dist = v8i32_add(v8i32_abs(rel.data[0]), v8i32_abs(rel.data[1]));
			V8B32 vecc_mask5 = v8i32_lt(dist, v8i32_set1(rad)); { // vector if
				V8B32 vecc_mask6 = v8b32_and(vecc_mask5, v8i32_gt(x, v8i32_set1(x_start))); { // vector if
					V8B32 vecc_mask7 = v8b32_and(vecc_mask6, v8i32_lt(x, v8i32_set1(x_end))); { // vector if
						framebuffer[(y_offset + xv)] = v8u32_blend(framebuffer[(y_offset + xv)], v8u32_set1(col), vecc_mask7);
					};
				};
			};
		};
	};
}

static Hit intersect_ray_aabb(Aos2F32 pos, Aos2F32 dir, Aos2F32 box_min, Aos2F32 box_max) {
	const Aos2F32 inv_dir = aos2f32_div(aos2f32_set1(1.0f), dir);
	const Aos2F32 t1 = aos2f32_mul(aos2f32_sub(box_min, pos), inv_dir);
	const Aos2F32 t2 = aos2f32_mul(aos2f32_sub(box_max, pos), inv_dir);
	Hit result = {0};
	result.tmin = f32_max(f32_min(t1.data[0], t2.data[0]), f32_min(t1.data[1], t2.data[1]));
	result.tmax = f32_min(f32_max(t1.data[0], t2.data[0]), f32_max(t1.data[1], t2.data[1]));
	result.hit = (B8)(result.tmax >= f32_max(0.0f, result.tmin));
	return result;
}

static F32 wave_sin(F32 t) {
	return f32_sin((2.0f * PI) * t);
}

static F32 wave_square(F32 t) {
	if (((I32)t & 1) == 0) {
		return 1.0f;
	} else {
		return -1.0f;
	};
}

static F32 wave_saw(F32 t) {
	return (f32_fract(t) - 0.5f) * 2.0f;
}

static F32 wave_triangle(F32 t) {
	return (f32_abs((t + 0.25f) - f32_round(t + 0.25f)) * 4.0f) - 1.0f;
}

static F32 wave_noise(F32 t) {
	return (((F32)hash_u32((U32)t) / (F32)4294967295) - 0.5f) * 2.0f;
}

static F32 sample_t(I32 index) {
	return (F32)index / (F32)AUDIO_SAMPLE_RATE;
}

static void play_sound(I32 sound) {
	g_sound_sample.data[sound] = 0;
	g_sound_rand.data[sound] = rand_f32();
}

static void draw_text(V8U32* framebuffer, Aos2I32 resolution, String text, Aos2I32 pos, U32 color) {
	for (I32 i = 0; i < text.len; i = i + 1) {
		draw_glyph(framebuffer, resolution, g_glyphs.data[((I32)text.data[i] - GLYPH_ASCII_FIRST)], {{pos.data[0], pos.data[1]}}, color);
		pos.data[0] = pos.data[0] + (GLYPH_WIDTH + 1);
	};
}

static void draw_glyph(V8U32* framebuffer, Aos2I32 resolution, U32 glyph, Aos2I32 pos, U32 color) {
	if (pos.data[0] < 0) {
		return ;
	};
	if (pos.data[1] < 0) {
		return ;
	};
	if (pos.data[0] > (resolution.data[0] - GLYPH_WIDTH)) {
		return ;
	};
	if (pos.data[1] > (resolution.data[1] - GLYPH_WIDTH)) {
		return ;
	};
	const I32 x_pos = pos.data[0] / vector_width;
	const I32 x_blocks = resolution.data[0] / vector_width;
	const I32 sub_x = pos.data[0] % vector_width;
	const V8B32 x_mask_0 = v8b32_and(v8i32_ge(vector_index, v8i32_set1(sub_x)), v8i32_lt(vector_index, v8i32_set1(sub_x + GLYPH_WIDTH)));
	if (v8b32_reduce_any(x_mask_0)) {
		const V8U32 x_shift = v8i32_to_v8u32(v8i32_sub(vector_index, v8i32_set1(sub_x)));
		for (I32 y = 0; y < GLYPH_HEIGHT; y = y + 1) {
			const V8U32 shift = v8u32_add(x_shift, v8u32_set1((U32)(y * GLYPH_WIDTH)));
			const V8U32 bit = v8u32_and(v8u32_srv(v8u32_set1(glyph), shift), v8u32_set1(1));
			V8B32 vecc_mask8 = v8b32_and(v8u32_neq(bit, v8u32_set1(0)), x_mask_0); { // vector if
				framebuffer[((x_pos + 0) + ((pos.data[1] + y) * x_blocks))] = v8u32_blend(framebuffer[((x_pos + 0) + ((pos.data[1] + y) * x_blocks))], v8u32_set1(color), vecc_mask8);
			};
		};
	};
	const V8B32 x_mask_1 = v8i32_lt(v8i32_add(vector_index, v8i32_set1(vector_width)), v8i32_set1(sub_x + GLYPH_WIDTH));
	if (v8b32_reduce_any(x_mask_1)) {
		const V8U32 x_shift = v8i32_to_v8u32(v8i32_sub(v8i32_add(vector_index, v8i32_set1(vector_width)), v8i32_set1(sub_x)));
		for (I32 y = 0; y < GLYPH_HEIGHT; y = y + 1) {
			const V8U32 shift = v8u32_add(x_shift, v8u32_set1((U32)(y * GLYPH_WIDTH)));
			const V8U32 bit = v8u32_and(v8u32_srv(v8u32_set1(glyph), shift), v8u32_set1(1));
			V8B32 vecc_mask12 = v8b32_and(v8u32_neq(bit, v8u32_set1(0)), x_mask_1); { // vector if
				framebuffer[((x_pos + 1) + ((pos.data[1] + y) * x_blocks))] = v8u32_blend(framebuffer[((x_pos + 1) + ((pos.data[1] + y) * x_blocks))], v8u32_set1(color), vecc_mask12);
			};
		};
	};
}

static U32 rand_u32() {
	g_seed = (g_seed * 214013) + 2531011;
	return (g_seed >> 16) & 32767;
}

static F32 rand_f32() {
	return (F32)rand_u32() / 32767.0f;
}

static U32 hash_u32(U32 x) {
	x = x ^ (x >> 16);
	x = x * 2146121005;
	x = x ^ (x >> 15);
	x = x * 2221713035;
	x = x ^ (x >> 16);
	return x;
}

static U32 color_to_u32(Aos4U8 col) {
	U32 result = 0;
	result = (U32)col.data[2];
	result = result | ((U32)col.data[1] << 8);
	result = result | ((U32)col.data[0] << 16);
	result = result | ((U32)col.data[3] << 24);
	return result;
}

static Aos2F32 normalize(Aos2F32 x) {
	return aos2f32_mul(x, aos2f32_set1(f32_rsqrt(length2(x))));
}

static F32 length2(Aos2F32 x) {
	return (x.data[0] * x.data[0]) + (x.data[1] * x.data[1]);
}

static F32 length(Aos2F32 x) {
	return f32_sqrt((x.data[0] * x.data[0]) + (x.data[1] * x.data[1]));
}

static F32 dot(Aos2F32 a, Aos2F32 b) {
	return (a.data[0] * b.data[0]) + (a.data[1] * b.data[1]);
}

#endif // VECC_IMPL
