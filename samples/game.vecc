// Small 2d game

const export RESOLUTION_X I32 = 8 * 36
const export RESOLUTION_Y I32 = 8 * 20
const export RESOLUTION_SCALE I32 = 6

const export KEY_LEFT_BIT   U32 = 1 << 0
const export KEY_RIGHT_BIT  U32 = 1 << 1
const export KEY_UP_BIT     U32 = 1 << 2
const export KEY_DOWN_BIT   U32 = 1 << 3
const export KEY_Z_BIT      U32 = 1 << 4
const export KEY_X_BIT      U32 = 1 << 5

struct Player {
    pos         [2]F32
    vel         [2]F32
    dir         [2]F32
    health      F32
    gun_timer   F32
}

mut player Player

struct Bullet {
    used    B8
    pos     [2]F32
    vel     [2]F32
    timer   F32
}

mut g_bullets [64]Bullet

procedure hash (mut n U32) U32 {
    n = (n << 13) ^ n
    n *= (((n * n) * 15731) + 789221)
    n += 1376312589
    return n
}

mut g_rnd U32 = 12093812093

procedure export compute_frame (
    immut vector framebuffer    [^]U32
    immut resolution            [2]I32
    immut time                  F32
    immut delta                 F32
    immut frame                 I32
    immut keys                  U32
) {
    g_rnd = hash(g_rnd)
    mut clear_mask U32 = reinterpret(U32, delta)
    clear_mask = !clear_mask

    for i I32; i < ((resolution.x * resolution.y) / vector_width); i += 1 {
        // immut offs U32 = conv(U32, (i + frame) & 127)
        // framebuffer[i] = (framebuffer[i] & 0x12345678)
        immut vector c U32 = framebuffer[i]
        // framebuffer[i] = c & 0x22222222
        framebuffer[i] = 0
        // framebuffer[i] = (framebuffer[i] & (conv(U32, i + (frame & 31))))
    }

    {
        mut dir [2]F32
        mut aiming Bool
        if (keys & KEY_LEFT_BIT ) != 0 { dir.x += -1; aiming = true }
        if (keys & KEY_RIGHT_BIT) != 0 { dir.x +=  1; aiming = true }
        if (keys & KEY_UP_BIT   ) != 0 { dir.y += -1; aiming = true }
        if (keys & KEY_DOWN_BIT ) != 0 { dir.y +=  1; aiming = true }

        player.gun_timer += delta
        immut shooting B32 = (keys & KEY_X_BIT) != 0
        if shooting & (player.gun_timer > 0.1) {
            player.gun_timer = 0
            player.vel -= player.dir * 50
            for i I32; i < 64; i += 1 {
                if !g_bullets[i].used {
                    g_bullets[i] = {
                        true
                        player.pos + (player.dir * 3)
                        player.dir * 200
                        0
                    }
                    break
                }
            }
        }

        if aiming {
            if !shooting {
                player.dir = dir
            }
        }
        player.vel *= 0.9
        player.vel += dir * (delta * 1000)
        player.pos += player.vel * delta

        draw_octagon(framebuffer, resolution, conv(I32, player.pos), 3, 5, {255; 255; 0; 0}, true)

        mut gun_pos [2]I32 = conv(I32, player.pos)
        gun_pos.x += conv(I32, (player.dir.x * 3) * min(player.gun_timer * 10, 1.0))
        gun_pos.y += conv(I32, (player.dir.y * 3) * min(player.gun_timer * 10, 1.0))
        gun_pos.y += 1

        mut gun_size [2]I32 = {6; 2}
        if player.dir.x == 0 {
            gun_size = {gun_size.y + 1; gun_size.x - 1}
        }

        draw_rect(framebuffer, resolution, gun_pos - {gun_size.x / 2; gun_size.y/2}, gun_size, {255; 255; 255; 255})
    }

    for i I32; i < 64; i += 1 {
        mut bullet Bullet = g_bullets[i]

        if bullet.timer > 1 {
            bullet.timer = 0
            bullet.used = false
        }

        if bullet.used {
            bullet.pos += bullet.vel * delta
            bullet.timer += delta

            draw_octagon(framebuffer, resolution, conv(I32, bullet.pos), 2, 2, {0; 255; 255; 0}, true)
        }

        g_bullets[i] = bullet
    }

    immut w I32 = conv(I32, 150.0 + (100.0 * sin(time * 0.5)))
}

procedure draw_rect (
    immut vector framebuffer    [^]U32
    immut resolution            [2]I32
    immut pos                   [2]I32
    immut size                  [2]I32
    immut color                 [4]U8
) {
    immut col U32 = reinterpret(U32, color)
    immut x_end I32 = pos.x + size.x
    immut x_range [2]I32 = {
        clamp(pos.x, 0, resolution.x) / vector_width
        ((clamp(x_end, 0, resolution.x) + vector_width) - 1) / vector_width
    }
    immut y_range [2]I32 = {
        clamp(pos.y         , 0, resolution.y)
        clamp(pos.y + size.y, 0, resolution.y)
    }
    for y I32 = y_range[0]; y < y_range[1]; y += 1 {
        immut y_offset I32 = y * (resolution.x / vector_width)
        // Note: this could be split into two loops
        for xv I32 = x_range[0]; xv < x_range[1]; xv += 1 {
            immut vector x I32 = vector_index + (xv * vector_width)
            if x > pos.x {
                if x < x_end {
                    framebuffer[y_offset + xv] = col
                }
            }
        }
    }
}

procedure draw_octagon (
    immut vector framebuffer    [^]U32
    immut resolution            [2]I32
    immut pos                   [2]I32
    immut size                  I32
    immut rad                   I32
    immut color                 [4]U8
    immut vector mask           B32
) {
    immut col U32 = reinterpret(U32, color)
    immut x_start I32 = pos.x - size
    immut x_end   I32 = pos.x + size
    immut x_range [2]I32 = {
        clamp(x_start, 0, resolution.x) / vector_width
        ((clamp(x_end  , 0, resolution.x) + vector_width) - 1) / vector_width
    }
    immut y_range [2]I32 = {
        clamp(pos.y - size, 0, resolution.y)
        clamp(pos.y + size, 0, resolution.y)
    }
    for y I32 = y_range[0]; y < y_range[1]; y += 1 {
        immut y_offset I32 = y * (resolution.x / vector_width)
        // Note: this could be split into two loops
        for xv I32 = x_range[0]; xv < x_range[1]; xv += 1 {
            immut vector x I32 = vector_index + (xv * vector_width)

            immut vector rel [2]I32 = {x; y} - pos
            immut vector dist I32 = abs(rel.x) + abs(rel.y)

            if dist < rad {
                if x > x_start {
                    if x < x_end {
                        framebuffer[y_offset + xv] = col
                    }
                }
            }
        }
    }
}

procedure normalize(immut x [2]F32) [2]F32 {
    return x * rsqrt(length2(x))
}

procedure length2(immut x [2]F32) F32 {
    return (x.x*x.x) + (x.y*x.y)
}

procedure length(immut x [2]F32) F32 {
    return sqrt((x.x*x.x) + (x.y*x.y))
}

procedure dot(immut a [2]F32; immut b [2]F32) F32 {
    return (a.x*b.x) + (a.y*b.y)
}