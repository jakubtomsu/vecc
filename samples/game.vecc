// Juiced up topdown shooter 2d game
//
// Controls:
// Arrows - movement
// X      - shoot forward
// Z      - shoot backward
//
// MANY THINGS ARE A TOTAL HACK AND WILL NEED TO BE CHANGED LATER!!!
//

const export SAMPLE_NAME String = "PLUS120"

const export RESOLUTION_X I32 = 8 * 30
const export RESOLUTION_Y I32 = 8 * 30
const export RESOLUTION_SCALE I32 = 4

const export KEY_LEFT_BIT   U32 = 1 << 0
const export KEY_RIGHT_BIT  U32 = 1 << 1
const export KEY_UP_BIT     U32 = 1 << 2
const export KEY_DOWN_BIT   U32 = 1 << 3
const export KEY_Z_BIT      U32 = 1 << 4
const export KEY_X_BIT      U32 = 1 << 5

const PLAYER_POWERUP_FAST_FIRE  I32 = 0
const PLAYER_POWERUP_SHOTGUN    I32 = 1
const PLAYER_POWERUP_EXPLOSIVE  I32 = 2

const POWERUP_FAST_FIRE_COLOR [4]U8 = {0; 255; 0; 0}
const POWERUP_SHOTGUN_COLOR   [4]U8 = {255; 255; 0; 0}
const POWERUP_EXPLOSIVE_COLOR [4]U8 = {0; 255; 255; 0}

struct Player {
    pos             [2]F32
    vel             [2]F32
    dir             [2]F32
    gun_timer       F32
    powerup_timer   [3]F32
    particle_timer  F32
}

mut player Player

struct Item {
    pos     [2]F32
    powerup I32
    timer   F32
}

mut g_items [64]Item

struct Bullet {
    used    B8
    pos     [2]F32
    vel     [2]F32
    timer   F32
    level   U8
    explode B8
}

mut g_bullets [64]Bullet

struct Effect {
    pos     [2]F32
    rad     F32
    timer   F32
    dur     F32
    color   [4]U8
}

mut g_effects [128]Effect

struct Enemy {
    pos             [2]F32
    vel             [2]F32
    speed           F32
    health          F32
    damage_timer    F32
    size            U8
    state           U8
    kind            U8
}

const ENEMY_STATE_DEAD      U8 = 0
const ENEMY_STATE_ALIVE     U8 = 1

const ENEMY_COLOR_NORMAL [4]U8 = {255; 50; 200; 0}
const ENEMY_COLOR_FAST   [4]U8 = {200; 0; 255; 0}
const ENEMY_COLOR_BIG    [4]U8 = {255; 10; 100; 0}

const GAME_MAX_TIME F32 = 120

mut g_enemies [64]Enemy

mut g_enemy_spawn_timer F32 = 5
mut g_game_timer F32 = 0

mut g_seed U32 = 1

mut g_camera [2]I32
mut g_shake F32

mut g_hit_pause F32

procedure rand_u32 () U32 {
    g_seed = (g_seed * 0x343fd) + 0x269ec3
    return (g_seed >> 16) & 32767
}

procedure rand_f32 () F32 {
    return conv(F32, rand_u32()) / 32767.0
}

procedure color_to_u32 (immut col [4]U8) U32 {
    mut result U32
    result  = conv(U32, col.b)
    result |= conv(U32, col.g) << 8
    result |= conv(U32, col.r) << 16
    result |= conv(U32, col.a) << 24
    return result
}

procedure spawn_item (
    immut pos     [2]F32
    immut powerup I32
) {
    for i I32; i < 64; i += 1 {
        mut item Item = g_items[i]
        if item.powerup == -1 {
            item.pos = pos
            item.powerup = powerup
            item.timer = 0
            g_items[i] = item
            break
        }
    }
}

procedure spawn_effect (
    immut pos   [2]F32
    immut rad   F32
    immut dur   F32
    immut col   [4]U8
) {
    for i I32; i < 128; i += 1 {
        mut effect Effect = g_effects[i]
        if effect.timer > effect.dur {
            effect.pos = pos
            effect.rad = rad
            effect.timer = 0
            effect.dur = dur
            effect.color = col
            g_effects[i] = effect
            break
        }
    }
}

procedure reset_game () {
    player.pos = {conv(F32, RESOLUTION_X); conv(F32, RESOLUTION_Y)} / 2

    player.vel = 0
    player.gun_timer = 0
    player.powerup_timer = {0; 0; 0}

    for i I32; i < 64; i += 1 {
        g_items[i].powerup = -1
    }

    for i I32; i < 64; i += 1 {
        g_bullets[i].used = false
    }

    for i I32; i < 64; i += 1 {
        g_enemies[i].pos = -100
        g_enemies[i].state = ENEMY_STATE_DEAD
    }

    for i I32; i < 64; i += 1 {
        g_effects[i].dur = -1
    }

    g_enemy_spawn_timer = 0
    g_game_timer = 0
    g_shake = 40
}

mut g_hit_sound F32 = 1000
mut g_sample_index I32

procedure export compute_frame (
    immut vector framebuffer    [^]U32
    immut resolution            [2]I32
    immut time                  F32
    immut delta                 F32
    immut frame                 I32
    immut keys                  U32
    immut audio_buffer          [^]F32
    immut audio_samples         I32
) {
    if frame == 0 {
        reset_game()
    }

    immut num_pixel_blocks I32 = (resolution.x * resolution.y) / vector_width

    mut should_hit_pause B32 = g_hit_pause > 0
    g_hit_pause -= delta
    if should_hit_pause {
        for i I32; i < num_pixel_blocks; i += 1 {
            immut vector c U32 = framebuffer[i]
            framebuffer[i] = c | color_to_u32({10;10;10;0})
        }
        return
    }

    g_game_timer += delta

    mut end_game Bool

    mut clear_mask U32 = reinterpret(U32, delta)
    clear_mask = !clear_mask

    for i I32; i < num_pixel_blocks; i += 1 {
        immut vector c U32 = framebuffer[i]
        framebuffer[i] = (c << 5) // | color_to_u32({0;255;0;0})
    }

    // if (frame & 1) == 0 {
    //     for i I32; i < num_pixel_blocks; i += 1 {
    //         immut vector c U32 = framebuffer[i]
    //         framebuffer[i] &= {0x55555555; 0x11111111; 0x55555555; 0x11111111; 0x55555555; 0x11111111; 0x55555555; 0x11111111}
    //     }
    // } else {
    //     for i I32; i < num_pixel_blocks; i += 1 {
    //         immut vector c U32 = framebuffer[i]
    //         framebuffer[i] &= {0x11111111; 0x55555555; 0x11111111; 0x55555555; 0x11111111; 0x55555555; 0x11111111; 0x55555555}
    //     }
    // }

    g_camera = {
        conv(I32, round((rand_f32() - 0.5) * g_shake))
        conv(I32, round((rand_f32() - 0.5) * g_shake))
    }

    g_shake = max(0.0, g_shake - (delta * 50))

    for i I32; i < 64; i += 1 {
        mut enemy Enemy = g_enemies[i]

        if enemy.state != ENEMY_STATE_DEAD {
            continue
        }

        draw_octagon(framebuffer, resolution, conv(I32, enemy.pos), 5, 6, {60; 50; 40; 0},
            // {true; false; true; false; true; false; true; false})
            true)
    }

    for i I32; i < 64; i += 1 {
        mut item Item = g_items[i]

        if item.powerup == -1 {
            continue
        }

        item.timer += delta

        if item.timer > 11 {
            item.powerup = -1
        }

        if length2(item.pos - player.pos) < (10 * 10) {
            if player.powerup_timer[item.powerup] < 0 {
                player.powerup_timer[item.powerup] = 0
            }
            player.powerup_timer[item.powerup] += 7
            item.powerup = -1
        }

        g_items[i] = item

        mut rad F32 = round(2.2 + (sin((time + conv(F32, i * 13)) * 8) * 0.7))

        mut color [4]U8
        if item.powerup == PLAYER_POWERUP_FAST_FIRE  { color = POWERUP_FAST_FIRE_COLOR }
        if item.powerup == PLAYER_POWERUP_SHOTGUN    { color = POWERUP_SHOTGUN_COLOR }
        if item.powerup == PLAYER_POWERUP_EXPLOSIVE  { color = POWERUP_EXPLOSIVE_COLOR }

        if item.timer > 7 {
            if sin(item.timer * 30) > 0 {
                color = {0; 0; 0; 0}
            }
            rad = 3
        }

        draw_octagon(framebuffer, resolution,
            conv(I32, item.pos), conv(I32, rad), 100, color,
            // {true; false; true; false; true; false; true; false},
            true)
    }

    mut max_enemy_damage_timer F32
    mut oldest_corpse I32 = -1
    for i I32; i < 64; i += 1 {
        mut enemy Enemy = g_enemies[i]

        enemy.damage_timer += delta

        if enemy.state == ENEMY_STATE_DEAD {
            if enemy.damage_timer > max_enemy_damage_timer {
                max_enemy_damage_timer = enemy.damage_timer
                oldest_corpse = i
            }
            g_enemies[i] = enemy
            continue
        }

        enemy.vel += normalize(player.pos - enemy.pos) * (delta * (enemy.speed * 5))
        enemy.vel = normalize(enemy.vel) * clamp(length(enemy.vel), 0, enemy.speed)

        enemy.pos += enemy.vel * delta

        mut rad F32 = conv(F32, enemy.size) + 2
        if length2(enemy.pos - player.pos) < (rad * rad) {
            end_game = true
        }

        if enemy.health <= 0 {
            enemy.state = ENEMY_STATE_DEAD
            spawn_effect(enemy.pos, 9, 0.05, {255; 255; 255; 255})
            g_shake += 5
            g_hit_pause = 0.02

            mut p U32 = rand_u32() % 11
            if p < 3 {
                spawn_item(enemy.pos, conv(I32, p))
            }
        }

        mut color [4]U8
        color = ENEMY_COLOR_NORMAL
        if enemy.kind == 1 { color = ENEMY_COLOR_FAST }
        if enemy.kind == 2 { color = ENEMY_COLOR_BIG }

        if enemy.damage_timer < 0.05 {
            color = {255; 255; 255; 255}
        }

        mut enemy_pos [2]F32 = enemy.pos
        draw_octagon(framebuffer, resolution, conv(I32, enemy_pos), conv(I32, enemy.size), conv(I32, enemy.size+1), color, true)

        g_enemies[i] = enemy
    }

    g_enemy_spawn_timer += delta
    immut spawn_rate F32 = 0.2 + (1.2 * max(0.0, 1.0 - (g_game_timer / GAME_MAX_TIME)))
    if (g_enemy_spawn_timer > spawn_rate) & (oldest_corpse != -1) {
        g_enemy_spawn_timer = 0

        mut enemy Enemy = g_enemies[oldest_corpse]
        enemy.state = ENEMY_STATE_ALIVE

        const RAD F32 = 0
        if (rand_u32() & 1) == 0 {
            if (rand_u32() & 1) == 0 {
                enemy.pos.x = -RAD
            } else {
                enemy.pos.x = conv(F32, RESOLUTION_X) + RAD
            }
            enemy.pos.y = conv(F32, conv(I32, rand_u32()) % RESOLUTION_Y)
        } else {
            if (rand_u32() & 1) == 0 {
                enemy.pos.y = -RAD
            } else {
                enemy.pos.y = conv(F32, RESOLUTION_Y) + RAD
            }
            enemy.pos.x = conv(F32, conv(I32, rand_u32()) % RESOLUTION_X)
        }

        if (g_game_timer > 10) & ((rand_u32() % 4) == 0) {
            if (g_game_timer > 30) & ((rand_u32() % 6) == 0) {
                enemy.size = 14
                enemy.health = 18
                enemy.speed = 6
                enemy.kind = 2
            } else {
                enemy.size = 8
                enemy.health = 6
                enemy.speed = 8
                enemy.kind = 2
            }
        } else {
            if (g_game_timer > 5) & ((rand_u32() % 3) == 0) {
                enemy.size = 5
                enemy.health = 0.5
                enemy.speed = 30
                enemy.kind = 1
            } else {
                enemy.size = 6
                enemy.health = 2
                enemy.speed = 20
                enemy.kind = 0
            }
        }

        g_enemies[oldest_corpse] = enemy
    }

    for i I32 = 0; i < 128; i += 1 {
        mut effect Effect = g_effects[i]
        effect.timer += delta

        if effect.timer < effect.dur {
            draw_octagon(framebuffer, resolution, conv(I32, effect.pos),
                conv(I32, effect.rad), conv(I32, effect.rad * 1.5), reinterpret([4]U8, effect.color), true)
        }

        g_effects[i] = effect
    }

    {
        mut powerups [3]Bool
        for i I32; i < 3; i += 1 {
            player.powerup_timer[i] -= delta
            if player.powerup_timer[i] > 0 {
                powerups[i] = true
            }
        }

        mut dir [2]F32
        mut aiming Bool
        if (keys & KEY_LEFT_BIT ) != 0 { dir.x += -1 }
        if (keys & KEY_RIGHT_BIT) != 0 { dir.x +=  1 }
        if (keys & KEY_UP_BIT   ) != 0 { dir.y += -1 }
        if (keys & KEY_DOWN_BIT ) != 0 { dir.y +=  1 }
        aiming = conv(Bool, length2(dir) > 0)

        mut cooldown_time F32 = 0.1
        mut num_shots I32 = 1
        mut shot_spread F32 = 0.25
        mut bullet_level U8 = 0
        mut bullet_speed F32 = 300

        if powerups[PLAYER_POWERUP_FAST_FIRE] {
            cooldown_time *= 0.4
            bullet_speed *= 1.5
            bullet_level += 1
        }

        if powerups[PLAYER_POWERUP_SHOTGUN] {
            cooldown_time *= 2
            num_shots *= 4
            shot_spread *= 3
            bullet_level += 1
        }

        if powerups[PLAYER_POWERUP_EXPLOSIVE] {
            bullet_speed *= 0.7
            cooldown_time *= 2
            bullet_level += 1
        }

        player.gun_timer += delta

        mut shoot_dir F32 = 1
        mut shooting B32
        if (keys & KEY_X_BIT) != 0 { shoot_dir =  1; shooting = true }
        if (keys & KEY_Z_BIT) != 0 { shoot_dir = -1; shooting = true } // overwrite is intentional

        if shooting & (player.gun_timer > cooldown_time) {
            player.gun_timer = 0
            player.vel -= player.dir * (38 * shoot_dir)
            mut bullet_num I32 = 0
            g_shake = 1
            // muzzle flash
            spawn_effect(player.pos + (player.dir * (6 * shoot_dir)), 3, 0.01, {0;255;255; 0})
            for i I32; i < 64; i += 1 {
                if !g_bullets[i].used {
                    mut bdir [2]F32 = player.dir * shoot_dir
                    bdir.x += (rand_f32() - 0.5) * shot_spread
                    bdir.y += (rand_f32() - 0.5) * shot_spread
                    bdir = normalize(bdir)

                    g_bullets[i] = {
                        true
                        player.pos + (player.dir * 3)
                        bdir * bullet_speed
                        0
                        bullet_level
                        powerups[PLAYER_POWERUP_EXPLOSIVE]
                    }
                    bullet_num += 1
                    if bullet_num == num_shots {
                        break
                    }
                }
            }
        }

        if aiming {
            if !shooting {
                player.dir = dir
            }
        }

        if aiming {
            player.particle_timer += delta
            if player.particle_timer > 0.1 {
                player.particle_timer -= 0.1

                spawn_effect(player.pos, 1, rand_f32() * 8, {100; 100; 100; 0})
            }
        }

        player.vel *= 0.9 // HACK
        player.vel += dir * (delta * 1000)
        player.pos += player.vel * delta

        const RAD F32 = 5
        player.pos.x = clamp(player.pos.x, RAD, conv(F32, RESOLUTION_X) - RAD)
        player.pos.y = clamp(player.pos.y, RAD, conv(F32, RESOLUTION_Y) - RAD)

        mut player_pos [2]F32 = player.pos
        player_pos.y -= round((0.5 + (0.5 * sin(time * 25))) * clamp(length(player.vel), 0, 1))
        draw_octagon(framebuffer, resolution, conv(I32, player_pos), 3, 5, {255; 150; 0; 0}, true)

        mut gun_pos [2]I32 = conv(I32, player.pos)
        gun_pos.x += conv(I32, ((player.dir.x * shoot_dir) * 3) * min(player.gun_timer * 10, 1.0))
        gun_pos.y += conv(I32, ((player.dir.y * shoot_dir) * 3) * min(player.gun_timer * 10, 1.0))
        gun_pos.y += 1

        mut gun_size [2]I32 = {7; 2}
        if player.dir.x == 0 {
            gun_size = {gun_size.y + 1; gun_size.x - 1}
        }

        draw_rect(framebuffer, resolution, (gun_pos - {gun_size.x / 2; gun_size.y/2}) - g_camera, gun_size, {255; 255; 255; 255})
    }

    for i I32; i < 64; i += 1 {
        mut bullet Bullet = g_bullets[i]

        if bullet.timer > 0.4 {
            bullet.timer = 0
            bullet.used = false
        }

        if bullet.used {
            bullet.timer += delta

            immut move [2]F32 = bullet.vel * delta

            immut move_dir [2]F32 = normalize(move)

            mut tmin F32 = length(move)
            mut hit_enemy I32 = -1
            for ei I32; ei < 64; ei += 1 {
                immut enemy Enemy = g_enemies[ei]
                if enemy.state != ENEMY_STATE_ALIVE {
                    continue
                }
                immut hit Hit = intersect_ray_aabb(
                    bullet.pos,
                    move_dir,
                    enemy.pos - conv(F32, enemy.size + 1),
                    enemy.pos + conv(F32, enemy.size + 1),
                )

                if hit.hit & conv(B8, hit.tmin < tmin) {
                    tmin = hit.tmin
                    hit_enemy = ei
                }
            }

            if hit_enemy == -1 {
                bullet.pos += move
            } else {
                bullet.pos += move_dir * tmin
                bullet.used = false

                if bullet.explode {
                    spawn_effect(bullet.pos, 32, 0.01, {0; 255; 255; 0})
                    spawn_effect(bullet.pos, 22, 0.05, {255; 255; 255; 0})
                    g_hit_pause = 0.09

                    for ei I32; ei < 64; ei += 1 {
                        mut enemy Enemy = g_enemies[ei]
                        if enemy.state != ENEMY_STATE_ALIVE {
                            continue
                        }
                        if length2(enemy.pos - bullet.pos) < (32*32) {
                            enemy.health -= 3
                            enemy.damage_timer = 0
                            enemy.vel = 0
                            g_enemies[ei] = enemy
                        }
                    }
                } else {
                    spawn_effect(bullet.pos, 4, 0.1, {0; 255; 255; 0})
                }

                g_hit_sound = 0

                mut enemy Enemy = g_enemies[hit_enemy]
                enemy.health -= 1
                enemy.damage_timer = 0
                enemy.vel = bullet.vel
                g_enemies[hit_enemy] = enemy
            }

            draw_octagon(framebuffer, resolution, conv(I32, bullet.pos), 2, 2 + conv(I32, bullet.level), {0; 255; 255; 0}, true)
        }

        g_bullets[i] = bullet
    }

    if g_game_timer < GAME_MAX_TIME {
        draw_rect(framebuffer, resolution, {0; 1}, {RESOLUTION_X - 1; 1}, {100; 100; 100; 100})
        draw_rect(framebuffer, resolution, {0; 1}, {conv(I32, conv(F32, RESOLUTION_X) * (1.0 - (g_game_timer / GAME_MAX_TIME))); 1}, {255; 255; 255; 255})
    } else {
        draw_rect(framebuffer, resolution, {0; 1}, {RESOLUTION_X - 1; 1}, {255; 0; 0; 0})
    }

    draw_rect(framebuffer, resolution, {2; RESOLUTION_Y - 5},
        {max(0, conv(I32, 3.0 * ceil(player.powerup_timer[PLAYER_POWERUP_FAST_FIRE]))); 3}, POWERUP_FAST_FIRE_COLOR)
    draw_rect(framebuffer, resolution, {2; RESOLUTION_Y - 10},
        {max(0, conv(I32, 3.0 * ceil(player.powerup_timer[PLAYER_POWERUP_SHOTGUN]))); 3}, POWERUP_SHOTGUN_COLOR)
    draw_rect(framebuffer, resolution, {2; RESOLUTION_Y - 15},
        {max(0, conv(I32, 3.0 * ceil(player.powerup_timer[PLAYER_POWERUP_EXPLOSIVE]))); 3}, POWERUP_EXPLOSIVE_COLOR)

    g_hit_sound += delta * 8
    for i I32 = 0; i < audio_samples; i += 1 {
        immut t F32 = conv(F32, g_sample_index) / 44100.0
        mut freq F32 = 200.0 - (g_hit_sound * 20.0)
        mut s F32 = fract(t * freq) - 0.5
        s *= max(0.0, 1.0 - g_hit_sound) * 2.0
        audio_buffer[i] = s
        g_sample_index += 1
    }

    if end_game {
        reset_game()
        for i I32 = 0; i < num_pixel_blocks; i += 1 {
            framebuffer[i] = 0
        }
    }
}

procedure draw_rect (
    immut vector framebuffer    [^]U32
    immut resolution            [2]I32
    immut pos                   [2]I32
    immut size                  [2]I32
    immut color                 [4]U8
) {
    immut col U32 = color_to_u32(color)
    immut x_end I32 = pos.x + size.x
    immut x_range [2]I32 = {
        clamp(pos.x, 0, resolution.x) / vector_width
        ((clamp(x_end, 0, resolution.x) + vector_width) - 1) / vector_width
    }
    immut y_range [2]I32 = {
        clamp(pos.y         , 0, resolution.y)
        clamp(pos.y + size.y, 0, resolution.y)
    }
    for y I32 = y_range[0]; y < y_range[1]; y += 1 {
        immut y_offset I32 = y * (resolution.x / vector_width)
        // Note: this could be split into two loops
        for xv I32 = x_range[0]; xv < x_range[1]; xv += 1 {
            immut vector x I32 = vector_index + (xv * vector_width)
            if x > pos.x {
                if x < x_end {
                    framebuffer[y_offset + xv] = col
                }
            }
        }
    }
}

procedure draw_octagon (
    immut vector framebuffer    [^]U32
    immut resolution            [2]I32
    immut pos                   [2]I32
    immut size                  I32
    immut rad                   I32
    immut color                 [4]U8
    immut vector mask           B32
) {
    pos -= g_camera
    immut col U32 = color_to_u32(color)
    immut x_start I32 = pos.x - size
    immut x_end   I32 = pos.x + size
    immut x_range [2]I32 = {
        clamp(x_start, 0, resolution.x) / vector_width
        ((clamp(x_end  , 0, resolution.x) + vector_width) - 1) / vector_width
    }
    immut y_range [2]I32 = {
        clamp(pos.y - (size - 1), 0, resolution.y)
        clamp(pos.y + size, 0, resolution.y)
    }
    for y I32 = y_range[0]; y < y_range[1]; y += 1 {
        immut y_offset I32 = y * (resolution.x / vector_width)
        // Note: this could be split into two loops
        for xv I32 = x_range[0]; xv < x_range[1]; xv += 1 {
            immut vector x I32 = vector_index + (xv * vector_width)

            immut vector rel [2]I32 = {x; y} - pos
            immut vector dist I32 = abs(rel.x) + abs(rel.y)

            if mask {
                if dist < rad {
                    if x > x_start {
                        if x < x_end {
                            framebuffer[y_offset + xv] = col
                        }
                    }
                }
            }
        }
    }
}

procedure normalize(immut x [2]F32) [2]F32 {
    return x * rsqrt(length2(x))
}

procedure length2(immut x [2]F32) F32 {
    return (x.x*x.x) + (x.y*x.y)
}

procedure length(immut x [2]F32) F32 {
    return sqrt((x.x*x.x) + (x.y*x.y))
}

procedure dot(immut a [2]F32; immut b [2]F32) F32 {
    return (a.x*b.x) + (a.y*b.y)
}

struct Hit {
    tmin    F32
    tmax    F32
    hit     Bool
}

procedure intersect_ray_aabb (
    immut pos     [2]F32
    immut dir     [2]F32
    immut box_min [2]F32
    immut box_max [2]F32
) Hit {
    // https://tavianator.com/cgit/dimension.git/tree/libdimension/bvh/bvh.c#n196

    // This is actually correct, even though it appears not to handle edge cases
    // (dir.{x,y,z} == 0).  It works because the infinities that result from
    // dividing by zero will still behave correctly in the comparisons.  Rays
    // which are parallel to an axis and outside the box will have tmin == inf
    // or tmax == -inf, while rays inside the box will have tmin and tmax
    // unchanged.

    immut inv_dir [2]F32 = 1.0 / dir

    immut t1 [2]F32 = (box_min - pos) * inv_dir
    immut t2 [2]F32 = (box_max - pos) * inv_dir

    mut result Hit
    result.tmin = max(min(t1.x, t2.x), min(t1.y, t2.y))
    result.tmax = min(max(t1.x, t2.x), max(t1.y, t2.y))
    result.hit = conv(B8, result.tmax >= max(0.0, result.tmin))

    return result
}
