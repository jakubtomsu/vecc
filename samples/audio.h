#ifndef VECC_DEFINED
#define VECC_DEFINED 1

// WARNING: this file was generated by the VecC compiler.

#include <stdint.h>
#include <stdio.h>
#include <vecc_builtin.h>

typedef struct { I32 data[2]; } Aos2I32;
static Aos2I32 aos2i32_set(I32 v0, I32 v1) { return {{v0, v1}}; }
static Aos2I32 aos2i32_set1(I32 a) { return {{a, a}}; }
static Aos2I32 aos2i32_add(Aos2I32 a, Aos2I32 b) { return {{a.data[0] + b.data[0], a.data[1] + b.data[1]}}; }
static Aos2I32 aos2i32_sub(Aos2I32 a, Aos2I32 b) { return {{a.data[0] - b.data[0], a.data[1] - b.data[1]}}; }
static Aos2I32 aos2i32_mul(Aos2I32 a, Aos2I32 b) { return {{a.data[0] * b.data[0], a.data[1] * b.data[1]}}; }
static Aos2I32 aos2i32_div(Aos2I32 a, Aos2I32 b) { return {{a.data[0] / b.data[0], a.data[1] / b.data[1]}}; }
static Aos2I32 aos2i32_and(Aos2I32 a, Aos2I32 b) { return {{a.data[0] & b.data[0], a.data[1] & b.data[1]}}; }
static Aos2I32 aos2i32_or(Aos2I32 a, Aos2I32 b) { return {{a.data[0] | b.data[0], a.data[1] | b.data[1]}}; }
static Aos2I32 aos2i32_xor(Aos2I32 a, Aos2I32 b) { return {{a.data[0] ^ b.data[0], a.data[1] ^ b.data[1]}}; }
static Aos2I32 aos2i32_neg(Aos2I32 a) { return {{-a.data[0], -a.data[1]}}; }

// VECC exported constants

const String SAMPLE_NAME = {"Audio", 5};
const I32 RESOLUTION_X = 8 * 24;
const I32 RESOLUTION_Y = 8 * 24;
const I32 RESOLUTION_SCALE = 3;
const U32 KEY_LEFT_BIT = 1 << 0;
const U32 KEY_RIGHT_BIT = 1 << 1;
const U32 KEY_UP_BIT = 1 << 2;
const U32 KEY_DOWN_BIT = 1 << 3;
const U32 KEY_Z_BIT = 1 << 4;
const U32 KEY_X_BIT = 1 << 5;

// VECC exported function declarations
void compute_frame(V8U32* framebuffer, Aos2I32 resolution, F32 time, F32 delta, I32 frame, U32 keys, F32* audio_buffer, I32 audio_samples);
#endif // VECC_DEFINED


#ifdef VECC_IMPL

// VECC private function declarations

static U32 rand_u32();
static F32 rand_f32();

// VECC global variable declarations

I32 sample_index = 0;
F32 freq = 16.0f;
F32 loud = 0.5f;
I32 effect_sample = 0;
U32 g_seed = 1;

// VECC function definitions

static U32 rand_u32() {
	g_seed = (g_seed * 214013) + 2531011;
	return (g_seed >> 16) & 32767;
}

static F32 rand_f32() {
	return (F32)rand_u32() / 32767.0f;
}

void compute_frame(V8U32* framebuffer, Aos2I32 resolution, F32 time, F32 delta, I32 frame, U32 keys, F32* audio_buffer, I32 audio_samples) {
	if ((KEY_UP_BIT & keys) != 0) {
		loud = loud + delta;
	};
	if ((KEY_DOWN_BIT & keys) != 0) {
		loud = loud - delta;
	};
	if ((KEY_Z_BIT & keys) != 0) {
		effect_sample = 0;
	};
	loud = f32_clamp(loud, -1.0f, 1.0f);
	for (I32 i = 0; i < audio_samples; i = i + 1) {
		F32 saw = f32_sin((F32)sample_index / freq) * loud;
		F32 effect = f32_fract((F32)effect_sample * 0.05f);
		effect = effect + (rand_f32() - 0.5f);
		effect = effect / (((F32)effect_sample * 0.001f) + 1.0f);
		audio_buffer[i] = (saw + effect) * loud;
		sample_index = sample_index + 1;
		effect_sample = effect_sample + 1;
	};
	const F32 inv_res_y = 1.0f / (F32)resolution.data[1];
	for (I32 xv = 0; xv < (resolution.data[0] / vector_width); xv = xv + 1) {
		V8F32 smp = v8f32_set(audio_buffer[((xv * vector_width) + 0)], audio_buffer[((xv * vector_width) + 1)], audio_buffer[((xv * vector_width) + 2)], audio_buffer[((xv * vector_width) + 3)], audio_buffer[((xv * vector_width) + 4)], audio_buffer[((xv * vector_width) + 5)], audio_buffer[((xv * vector_width) + 6)], audio_buffer[((xv * vector_width) + 7)]);
		smp = v8f32_mul(v8f32_add(smp, v8f32_set1(1.0f)), v8f32_set1(0.5f));
		for (I32 y = 0; y < resolution.data[1]; y = y + 1) {
			const I32 y_offset = y * (resolution.data[0] / vector_width);
			const V8I32 x = v8i32_add(vector_index, v8i32_set1(xv * vector_width));
			const V8F32 dist = v8f32_abs(v8f32_sub(smp, v8f32_set1((F32)y * inv_res_y)));
			V8U32 col = {0};
			V8B32 vecc_mask10 = v8f32_lt(dist, v8f32_set1(0.0099999998f)); { // vector if
				col = v8u32_blend(col, v8u32_set1(2853284369), vecc_mask10);
			};
			V8B32 vecc_mask11 = v8f32_lt(dist, v8f32_set1(0.0049999999f)); { // vector if
				col = v8u32_blend(col, v8u32_set1(4280483618), vecc_mask11);
			};
			framebuffer[(y_offset + xv)] = col;
		};
	};
}

#endif // VECC_IMPL
