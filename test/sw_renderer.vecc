// Julia set fractal by iq:
// https://www.shadertoy.com/view/Mss3R8

const export RESOLUTION_X i32 = 320 * 4
const export RESOLUTION_Y i32 = 184 * 4

procedure export compute_frame (
    immut vector framebuffer    [^]u32
    immut resolution            [2]i32
    immut time                  f32
    immut delta                 f32
    immut frame                 i32
) {
    // non p dependent
    immut ltime f32 = 0.5 - (0.5*cos(time*0.06))
    immut zoom f32 = pow(0.9, 50.0*ltime)
    mut cen [2]f32
    // NOTE: missing initializer lists and some array programming
    cen.x = 0.2655
    cen.y = 0.301
    cen += (zoom*0.8) * cos(4.0+(2.0*ltime))

    mut c [2]f32
    c.x = -0.745
    c.y = 0.186
    c.x -= (0.045*zoom)*(1.0-(ltime*0.5))
    c.y -= (0.045*zoom)*(1.0-(ltime*0.5))

    mut vector inv_res [2]f32
    inv_res.x = rcp(conv(f32, resolution.x))
    inv_res.y = rcp(conv(f32, resolution.y))

    for y i32; y < resolution.y; y += 1 {
        for x i32; x < (resolution.x / vector_width); x += 1 {
            mut vector pixel_x i32 = (vector_index * 1) + (x * vector_width)

            mut vector uv [2]f32
            // uv.x = conv(f32, pixel_x) * inv_res.x
            // uv.y = conv(f32, y) inv_res.y

            mut vector col [4]f32
            // col.r = uv.x
            // col.g = (cos(uv.y * 50) * 0.5) + 0.5
            col.a = 1.0

            mut vector p [2]f32
            p.x = conv(f32, pixel_x)
            p.y = conv(f32, y)
            p.x = ((p.x * 2.0)-conv(f32, resolution.x)) * inv_res.y
            p.y = ((p.y * 2.0)-conv(f32, resolution.y)) * inv_res.y

            mut vector z [2]f32
            z.x = ((p.x-cen.x)*zoom) + cen.x
            z.y = ((p.y-cen.y)*zoom) + cen.y

            // only derivative length version
            mut vector ld2 f32
            ld2 = 1.0
            mut vector lz2 f32 = (z.x*z.x) + (z.y*z.y)
            mut vector break_mask b32 // hack
            for i i32; i < 256; i += 1 {
                ld2 = blend(ld2 * (lz2*4.0), ld2, break_mask)
                immut vector old_z [2]f32 = z
                z.x = ((old_z.x*old_z.x) - (old_z.y*old_z.y)) + c.x
                z.y = ((old_z.x*old_z.y)*2) + c.y
                lz2 = blend((z.x*z.x) + (z.y*z.y), lz2, break_mask)
                break_mask |= lz2 > 200.0
                if reduce_all(break_mask) {
                    break
                }
            }
            mut vector d f32 = sqrt(lz2/ld2) * log(lz2)

            immut vector scol f32 = sqrt(clamp((conv(vector(8, f32), 150.0)/zoom)*d, 0.0, 1.0))

            col.r = pow(scol, 0.9)
            col.g = pow(scol, 1.1)
            col.b = pow(scol, 1.4)
            col.a = 1

            // Store

            mut vector col_int [4]u32
            col_int.r = conv(u32, clamp(col.r, 0, 1) * 255.0)
            col_int.g = conv(u32, clamp(col.g, 0, 1) * 255.0)
            col_int.b = conv(u32, clamp(col.b, 0, 1) * 255.0)
            col_int.a = conv(u32, clamp(col.a, 0, 1) * 255.0)

            mut vector col_rgba u32
            col_rgba = col_int.b
            col_rgba |= col_int.g << 8
            col_rgba |= col_int.r << 16
            col_rgba |= col_int.a << 24

            immut index i32 = x + (y * (resolution.x / vector_width))
            framebuffer[index] = col_rgba
        }
    }
}

procedure normalize(immut x [3]f32) [3]f32 {
    return x * rsqrt(length2(x))
}

procedure length2(immut x [3]f32) f32 {
    return (x.x*x.x) + ((x.y*x.y) + (x.z*x.z))
}

procedure length(immut x [3]f32) f32 {
    return sqrt((x.x*x.x) + ((x.y*x.y) + (x.z*x.z)))
}

procedure dot(immut a [3]f32; immut b [3]f32) f32 {
    return (a.x*b.x) + ((a.y*b.y) + (a.z*b.z))
}