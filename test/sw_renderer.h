#ifndef VECC_DEFINED
#define VECC_DEFINED 1

// WARNING: this file was generated by the VecC compiler.

#include <stdint.h>
#include <stdio.h>
#include "vecc_builtin.h"

typedef struct { f32 data[3]; } Aos3f32;
typedef struct { i32 data[2]; } Aos2i32;
typedef struct { f32 data[2]; } Aos2f32;
typedef struct { v8f32 data[2]; } Aos2v8f32;
typedef struct { f32 data[4]; } Aos4f32;
typedef struct { v8f32 data[4]; } Aos4v8f32;
typedef struct { u32 data[4]; } Aos4u32;
typedef struct { v8u32 data[4]; } Aos4v8u32;
static Aos3f32 aos3f32_set1(f32 a) { return {{a, a, a}}; }
static Aos3f32 aos3f32_set(f32 v0, f32 v1, f32 v2) { return {{v0, v1, v2}}; }
static Aos3f32 aos3f32_add(Aos3f32 a, Aos3f32 b) {return {{a.data[0] + b.data[0], a.data[1] + b.data[1], a.data[2] + b.data[2], }};}
static Aos3f32 aos3f32_sub(Aos3f32 a, Aos3f32 b) {return {{a.data[0] - b.data[0], a.data[1] - b.data[1], a.data[2] - b.data[2], }};}
static Aos3f32 aos3f32_mul(Aos3f32 a, Aos3f32 b) {return {{a.data[0] * b.data[0], a.data[1] * b.data[1], a.data[2] * b.data[2], }};}
static Aos3f32 aos3f32_div(Aos3f32 a, Aos3f32 b) {return {{a.data[0] / b.data[0], a.data[1] / b.data[1], a.data[2] / b.data[2], }};}
static Aos2i32 aos2i32_set1(i32 a) { return {{a, a}}; }
static Aos2i32 aos2i32_set(i32 v0, i32 v1) { return {{v0, v1}}; }
static Aos2f32 aos2i32_to_aos2f32(Aos2i32 a) { return {{(f32)a.data[0], (f32)a.data[1]}}; }
static Aos2i32 aos2i32_add(Aos2i32 a, Aos2i32 b) {return {{a.data[0] + b.data[0], a.data[1] + b.data[1], }};}
static Aos2i32 aos2i32_sub(Aos2i32 a, Aos2i32 b) {return {{a.data[0] - b.data[0], a.data[1] - b.data[1], }};}
static Aos2i32 aos2i32_mul(Aos2i32 a, Aos2i32 b) {return {{a.data[0] * b.data[0], a.data[1] * b.data[1], }};}
static Aos2i32 aos2i32_and(Aos2i32 a, Aos2i32 b) {return {{a.data[0] & b.data[0], a.data[1] & b.data[1], }};}
static Aos2i32 aos2i32_or(Aos2i32 a, Aos2i32 b) {return {{a.data[0] | b.data[0], a.data[1] | b.data[1], }};}
static Aos2i32 aos2i32_xor(Aos2i32 a, Aos2i32 b) {return {{a.data[0] ^ b.data[0], a.data[1] ^ b.data[1], }};}
static Aos2f32 aos2f32_set1(f32 a) { return {{a, a}}; }
static Aos2f32 aos2f32_set(f32 v0, f32 v1) { return {{v0, v1}}; }
static Aos2i32 aos2f32_to_aos2i32(Aos2f32 a) { return {{(i32)a.data[0], (i32)a.data[1]}}; }
static Aos2f32 aos2f32_add(Aos2f32 a, Aos2f32 b) {return {{a.data[0] + b.data[0], a.data[1] + b.data[1], }};}
static Aos2f32 aos2f32_sub(Aos2f32 a, Aos2f32 b) {return {{a.data[0] - b.data[0], a.data[1] - b.data[1], }};}
static Aos2f32 aos2f32_mul(Aos2f32 a, Aos2f32 b) {return {{a.data[0] * b.data[0], a.data[1] * b.data[1], }};}
static Aos2f32 aos2f32_div(Aos2f32 a, Aos2f32 b) {return {{a.data[0] / b.data[0], a.data[1] / b.data[1], }};}
static Aos2v8f32 aos2v8f32_set1(v8f32 a) { return {{a, a}}; }
static Aos2v8f32 aos2v8f32_set(v8f32 v0, v8f32 v1) { return {{v0, v1}}; }
static Aos2v8f32 aos2v8f32_add(Aos2v8f32 a, Aos2v8f32 b) {return {{v8f32_add(a.data[0], b.data[0]), v8f32_add(a.data[1], b.data[1]), }};}
static Aos2v8f32 aos2v8f32_sub(Aos2v8f32 a, Aos2v8f32 b) {return {{v8f32_sub(a.data[0], b.data[0]), v8f32_sub(a.data[1], b.data[1]), }};}
static Aos2v8f32 aos2v8f32_mul(Aos2v8f32 a, Aos2v8f32 b) {return {{v8f32_mul(a.data[0], b.data[0]), v8f32_mul(a.data[1], b.data[1]), }};}
static Aos2v8f32 aos2v8f32_div(Aos2v8f32 a, Aos2v8f32 b) {return {{v8f32_div(a.data[0], b.data[0]), v8f32_div(a.data[1], b.data[1]), }};}
static Aos4f32 aos4f32_set1(f32 a) { return {{a, a, a, a}}; }
static Aos4f32 aos4f32_set(f32 v0, f32 v1, f32 v2, f32 v3) { return {{v0, v1, v2, v3}}; }
static Aos4u32 aos4f32_to_aos4u32(Aos4f32 a) { return {{(u32)a.data[0], (u32)a.data[1], (u32)a.data[2], (u32)a.data[3]}}; }
static Aos4f32 aos4f32_add(Aos4f32 a, Aos4f32 b) {return {{a.data[0] + b.data[0], a.data[1] + b.data[1], a.data[2] + b.data[2], a.data[3] + b.data[3], }};}
static Aos4f32 aos4f32_sub(Aos4f32 a, Aos4f32 b) {return {{a.data[0] - b.data[0], a.data[1] - b.data[1], a.data[2] - b.data[2], a.data[3] - b.data[3], }};}
static Aos4f32 aos4f32_mul(Aos4f32 a, Aos4f32 b) {return {{a.data[0] * b.data[0], a.data[1] * b.data[1], a.data[2] * b.data[2], a.data[3] * b.data[3], }};}
static Aos4f32 aos4f32_div(Aos4f32 a, Aos4f32 b) {return {{a.data[0] / b.data[0], a.data[1] / b.data[1], a.data[2] / b.data[2], a.data[3] / b.data[3], }};}
static Aos4v8f32 aos4v8f32_set1(v8f32 a) { return {{a, a, a, a}}; }
static Aos4v8f32 aos4v8f32_set(v8f32 v0, v8f32 v1, v8f32 v2, v8f32 v3) { return {{v0, v1, v2, v3}}; }
static Aos4v8f32 aos4v8f32_add(Aos4v8f32 a, Aos4v8f32 b) {return {{v8f32_add(a.data[0], b.data[0]), v8f32_add(a.data[1], b.data[1]), v8f32_add(a.data[2], b.data[2]), v8f32_add(a.data[3], b.data[3]), }};}
static Aos4v8f32 aos4v8f32_sub(Aos4v8f32 a, Aos4v8f32 b) {return {{v8f32_sub(a.data[0], b.data[0]), v8f32_sub(a.data[1], b.data[1]), v8f32_sub(a.data[2], b.data[2]), v8f32_sub(a.data[3], b.data[3]), }};}
static Aos4v8f32 aos4v8f32_mul(Aos4v8f32 a, Aos4v8f32 b) {return {{v8f32_mul(a.data[0], b.data[0]), v8f32_mul(a.data[1], b.data[1]), v8f32_mul(a.data[2], b.data[2]), v8f32_mul(a.data[3], b.data[3]), }};}
static Aos4v8f32 aos4v8f32_div(Aos4v8f32 a, Aos4v8f32 b) {return {{v8f32_div(a.data[0], b.data[0]), v8f32_div(a.data[1], b.data[1]), v8f32_div(a.data[2], b.data[2]), v8f32_div(a.data[3], b.data[3]), }};}
static Aos4u32 aos4u32_set1(u32 a) { return {{a, a, a, a}}; }
static Aos4u32 aos4u32_set(u32 v0, u32 v1, u32 v2, u32 v3) { return {{v0, v1, v2, v3}}; }
static Aos4f32 aos4u32_to_aos4f32(Aos4u32 a) { return {{(f32)a.data[0], (f32)a.data[1], (f32)a.data[2], (f32)a.data[3]}}; }
static Aos4u32 aos4u32_add(Aos4u32 a, Aos4u32 b) {return {{a.data[0] + b.data[0], a.data[1] + b.data[1], a.data[2] + b.data[2], a.data[3] + b.data[3], }};}
static Aos4u32 aos4u32_sub(Aos4u32 a, Aos4u32 b) {return {{a.data[0] - b.data[0], a.data[1] - b.data[1], a.data[2] - b.data[2], a.data[3] - b.data[3], }};}
static Aos4u32 aos4u32_mul(Aos4u32 a, Aos4u32 b) {return {{a.data[0] * b.data[0], a.data[1] * b.data[1], a.data[2] * b.data[2], a.data[3] * b.data[3], }};}
static Aos4u32 aos4u32_and(Aos4u32 a, Aos4u32 b) {return {{a.data[0] & b.data[0], a.data[1] & b.data[1], a.data[2] & b.data[2], a.data[3] & b.data[3], }};}
static Aos4u32 aos4u32_or(Aos4u32 a, Aos4u32 b) {return {{a.data[0] | b.data[0], a.data[1] | b.data[1], a.data[2] | b.data[2], a.data[3] | b.data[3], }};}
static Aos4u32 aos4u32_xor(Aos4u32 a, Aos4u32 b) {return {{a.data[0] ^ b.data[0], a.data[1] ^ b.data[1], a.data[2] ^ b.data[2], a.data[3] ^ b.data[3], }};}
static Aos4v8u32 aos4v8u32_set1(v8u32 a) { return {{a, a, a, a}}; }
static Aos4v8u32 aos4v8u32_set(v8u32 v0, v8u32 v1, v8u32 v2, v8u32 v3) { return {{v0, v1, v2, v3}}; }
static Aos4v8u32 aos4v8u32_add(Aos4v8u32 a, Aos4v8u32 b) {return {{v8u32_add(a.data[0], b.data[0]), v8u32_add(a.data[1], b.data[1]), v8u32_add(a.data[2], b.data[2]), v8u32_add(a.data[3], b.data[3]), }};}
static Aos4v8u32 aos4v8u32_sub(Aos4v8u32 a, Aos4v8u32 b) {return {{v8u32_sub(a.data[0], b.data[0]), v8u32_sub(a.data[1], b.data[1]), v8u32_sub(a.data[2], b.data[2]), v8u32_sub(a.data[3], b.data[3]), }};}
static Aos4v8u32 aos4v8u32_mul(Aos4v8u32 a, Aos4v8u32 b) {return {{v8u32_mul(a.data[0], b.data[0]), v8u32_mul(a.data[1], b.data[1]), v8u32_mul(a.data[2], b.data[2]), v8u32_mul(a.data[3], b.data[3]), }};}
static Aos4v8u32 aos4v8u32_and(Aos4v8u32 a, Aos4v8u32 b) {return {{v8u32_and(a.data[0], b.data[0]), v8u32_and(a.data[1], b.data[1]), v8u32_and(a.data[2], b.data[2]), v8u32_and(a.data[3], b.data[3]), }};}
static Aos4v8u32 aos4v8u32_or(Aos4v8u32 a, Aos4v8u32 b) {return {{v8u32_or(a.data[0], b.data[0]), v8u32_or(a.data[1], b.data[1]), v8u32_or(a.data[2], b.data[2]), v8u32_or(a.data[3], b.data[3]), }};}
static Aos4v8u32 aos4v8u32_xor(Aos4v8u32 a, Aos4v8u32 b) {return {{v8u32_xor(a.data[0], b.data[0]), v8u32_xor(a.data[1], b.data[1]), v8u32_xor(a.data[2], b.data[2]), v8u32_xor(a.data[3], b.data[3]), }};}

// VECC exported constants

const i32 RESOLUTION_X = (320 * 4);
const i32 RESOLUTION_Y = (184 * 4);

// VECC exported function declarations
void compute_frame(v8u32* framebuffer, Aos2i32 resolution, f32 time, f32 delta, i32 frame);
#endif // VECC_DEFINED


#ifdef VECC_IMPL

// VECC private function declarations

static Aos3f32 normalize(Aos3f32 x);
static f32 length2(Aos3f32 x);
static f32 length(Aos3f32 x);
static f32 dot(Aos3f32 a, Aos3f32 b);

// VECC global variable declarations


// VECC function definitions

void compute_frame(v8u32* framebuffer, Aos2i32 resolution, f32 time, f32 delta, i32 frame) {
	const f32 ltime = (0.5f - (0.5f * f32_cos((time * 0.119999997f))));
	const f32 zoom = f32_pow(0.89999998f, (50.0f * ltime));
	Aos2f32 cen = {0};
	cen.data[0] = 0.2655f;
	cen.data[1] = 0.301f;
	cen = aos2f32_add(cen, aos2f32_set1(((zoom * 0.8f) * f32_cos((4.0f + (2.0f * ltime))))));
	Aos2f32 c = {0};
	c.data[0] = -0.745f;
	c.data[1] = 0.186f;
	c = aos2f32_sub(c, aos2f32_set1(((0.045f * zoom) * (1.0f - (ltime * 0.5f)))));
	Aos2f32 inv_res = aos2f32_div(aos2f32_set1(1.0f), aos2i32_to_aos2f32(resolution));
	for (i32 y = 0; (y < resolution.data[1]); y = y + 1) {
		for (i32 x = 0; (x < (resolution.data[0] / vector_width)); x = x + 1) {
			v8i32 pixel_x = v8i32_add(vector_index, v8i32_set1((x * vector_width)));
			Aos2v8f32 uv = {0};
			uv.data[0] = v8f32_mul(v8i32_to_v8f32(pixel_x), v8f32_set1(inv_res.data[0]));
			uv.data[1] = v8f32_set1(((f32)y * inv_res.data[1]));
			Aos4v8f32 col = {0};
			col.data[3] = v8f32_set1(1.0f);
			Aos2v8f32 p = {0};
			p.data[0] = v8i32_to_v8f32(pixel_x);
			p.data[1] = v8f32_set1((f32)y);
			p.data[0] = v8f32_mul(v8f32_sub(v8f32_mul(p.data[0], v8f32_set1(2.0f)), v8f32_set1((f32)resolution.data[0])), v8f32_set1(inv_res.data[1]));
			p.data[1] = v8f32_mul(v8f32_sub(v8f32_mul(p.data[1], v8f32_set1(2.0f)), v8f32_set1((f32)resolution.data[1])), v8f32_set1(inv_res.data[1]));
			Aos2v8f32 z = {0};
			z.data[0] = v8f32_add(v8f32_mul(v8f32_sub(p.data[0], v8f32_set1(cen.data[0])), v8f32_set1(zoom)), v8f32_set1(cen.data[0]));
			z.data[1] = v8f32_add(v8f32_mul(v8f32_sub(p.data[1], v8f32_set1(cen.data[1])), v8f32_set1(zoom)), v8f32_set1(cen.data[1]));
			v8f32 ld2 = {0};
			ld2 = v8f32_set1(1.0f);
			v8f32 lz2 = v8f32_add(v8f32_mul(z.data[0], z.data[0]), v8f32_mul(z.data[1], z.data[1]));
			v8b32 break_mask = {0};
			for (i32 i = 0; (i < 256); i = i + 1) {
				ld2 = v8f32_blend(v8f32_mul(ld2, v8f32_mul(lz2, v8f32_set1(4.0f))), ld2, break_mask);
				const Aos2v8f32 old_z = z;
				z.data[0] = v8f32_add(v8f32_sub(v8f32_mul(old_z.data[0], old_z.data[0]), v8f32_mul(old_z.data[1], old_z.data[1])), v8f32_set1(c.data[0]));
				z.data[1] = v8f32_add(v8f32_mul(v8f32_mul(old_z.data[0], old_z.data[1]), v8f32_set1(2.0f)), v8f32_set1(c.data[1]));
				lz2 = v8f32_blend(v8f32_add(v8f32_mul(z.data[0], z.data[0]), v8f32_mul(z.data[1], z.data[1])), lz2, break_mask);
				break_mask = v8b32_or(break_mask, v8f32_gt(lz2, v8f32_set1(200.0f)));
				if (v8b32_reduce_all(break_mask)) {
					break;
				};
			};
			v8f32 d = v8f32_mul(v8f32_sqrt(v8f32_div(lz2, ld2)), v8f32_log(lz2));
			const v8f32 scol = v8f32_sqrt(v8f32_clamp(v8f32_mul(v8f32_div(v8f32_set1(150.0f), v8f32_set1(zoom)), d), v8f32_set1(0.0f), v8f32_set1(1.0f)));
			col.data[0] = v8f32_pow(scol, v8f32_set1(0.89999998f));
			col.data[1] = v8f32_pow(scol, v8f32_set1(1.1f));
			col.data[2] = v8f32_pow(scol, v8f32_set1(1.39999998f));
			col.data[3] = v8f32_set1(1.0f);
			Aos4v8u32 col_int = {0};
			col_int.data[0] = v8f32_to_v8u32(v8f32_mul(v8f32_clamp(col.data[0], v8f32_set1(0.0f), v8f32_set1(1.0f)), v8f32_set1(255.0f)));
			col_int.data[1] = v8f32_to_v8u32(v8f32_mul(v8f32_clamp(col.data[1], v8f32_set1(0.0f), v8f32_set1(1.0f)), v8f32_set1(255.0f)));
			col_int.data[2] = v8f32_to_v8u32(v8f32_mul(v8f32_clamp(col.data[2], v8f32_set1(0.0f), v8f32_set1(1.0f)), v8f32_set1(255.0f)));
			col_int.data[3] = v8f32_to_v8u32(v8f32_mul(v8f32_clamp(col.data[3], v8f32_set1(0.0f), v8f32_set1(1.0f)), v8f32_set1(255.0f)));
			v8u32 col_rgba = {0};
			col_rgba = col_int.data[2];
			col_rgba = v8u32_or(col_rgba, v8u32_sl(col_int.data[1], 8));
			col_rgba = v8u32_or(col_rgba, v8u32_sl(col_int.data[0], 16));
			col_rgba = v8u32_or(col_rgba, v8u32_sl(col_int.data[3], 24));
			const i32 index = (x + (y * (resolution.data[0] / vector_width)));
			framebuffer[index] = col_rgba;
		};
	};
}

static Aos3f32 normalize(Aos3f32 x) {
	return aos3f32_mul(x, aos3f32_set1(f32_rsqrt(length2(x))));
}

static f32 length2(Aos3f32 x) {
	return ((x.data[0] * x.data[0]) + ((x.data[1] * x.data[1]) + (x.data[2] * x.data[2])));
}

static f32 length(Aos3f32 x) {
	return f32_sqrt(((x.data[0] * x.data[0]) + ((x.data[1] * x.data[1]) + (x.data[2] * x.data[2]))));
}

static f32 dot(Aos3f32 a, Aos3f32 b) {
	return ((a.data[0] * b.data[0]) + ((a.data[1] * b.data[1]) + (a.data[2] * b.data[2])));
}

#endif // VECC_IMPL
